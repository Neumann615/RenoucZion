## 非原始值的响应式方案

在上一章中，我们着重讨论了响应系统的概念与实现，并简单介
绍了响应式数据的基本原理。本章中我们把目光聚焦在响应式数据本
身，深入探讨实现响应式数据都需要考虑哪些内容，其中的难点又是
什么。实际上，实现响应式数据要比想象中难很多，并不是像上一章
讲述的那样，单纯地拦截 get/set 操作即可。举例来说，如何拦截
for...in 循环？track 函数如何追踪拦截到的 for...in 循环？类
似的问题还有很多。除此之外，我们还应该考虑如何对数组进行代
理。Vue.js 3 还支持集合类型，如 Map、Set、WeakMap 以及
WeakSet 等，那么应该如何对集合类型进行代理呢？实际上，想要实
现完善的响应式数据，我们需要深入语言规范。本章在揭晓答案的同
时，也会从语言规范的层面来分析原因，让你对响应式数据有更深入
的理解。

## 理解 Proxy 和 Reflect

既然 Vue.js 3 的响应式数据是基于 Proxy 实现的，那么我们就有
必要了解 Proxy 以及与之相关联的 Reflect。什么是 Proxy 呢？简
单地说，使用 Proxy 可以创建一个代理对象。它能够实现对其他对象
的代理，这里的关键词是其他对象，也就是说，Proxy 只能代理对
象，无法代理非对象值，例如字符串、布尔值等。那么，代理指的是
什么呢？所谓代理，指的是对一个对象基本语义的代理。它允许我们
拦截并重新定义对一个对象的基本操作。这句话的关键词比较多，我
们逐一解释。

什么是基本语义？给出一个对象 obj，可以对它进行一些操作，例如读取属性值、设置属性值：

```javascript
obj.foo // 读取属性 foo 的值
obj.foo++ // 读取和设置属性 foo 的值
```

类似这种读取、设置属性值的操作，就属于基本语义的操作，即基本操作。既然是基本操作，那么它就可以使用 Proxy 拦截：

```javascript
 const p = new Proxy(obj, {
    // 拦截读取属性操作
    get() { /*...*/
    },
    // 拦截设置属性操作
    set() { /*...*/
    }
})
```

如以上代码所示，Proxy 构造函数接收两个参数。第一个参数是被代理的对象，第二个参数也是一个对象，这个对象是一组夹子（trap）。其中
get 函数用来拦截读取操作，set 函数用来拦截设置操作。

在 JavaScript 的世界里，万物皆对象。例如一个函数也是一个对象，所以调用函数也是对一个对象的基本操作：

```javascript
const fn = (name) => {
    console.log('我是：', name)
}

// 调用函数是对对象的基本操作
fn()
```

因此，我们可以用 Proxy 来拦截函数的调用操作，这里我们使用apply 拦截函数的调用：

```javascript
 const p2 = new Proxy(fn, {
    // 使用 apply 拦截函数调用
    apply(target, thisArg, argArray) {
        target.call(thisArg, ...argArray)
    }
})

p2('hcy') // 输出：'我是：hcy'
```

上面两个例子说明了什么是基本操作。Proxy 只能够拦截对一个对象的基本操作。那么，什么是非基本操作呢？其实调用对象下的方法就是典型的非基本操作，我们叫它
**复合操作**：

```javascript
obj.fn()
```

实际上，调用一个对象下的方法，是由两个基本语义组成的。第
一个基本语义是 get，即先通过 get 操作得到 obj.fn 属性。第二个
基本语义是函数调用，即通过 get 得到 obj.fn 的值后再调用它，也
就是我们上面说到的 apply。理解 Proxy 只能够代理对象的基本语义
很重要，后续我们讲解如何实现对数组或 Map、Set 等数据类型的代
理时，都利用了 Proxy 的这个特点。

理解了 Proxy，我们再来讨论 Reflect。Reflect 是一个全局对象，其下有许多方法，例如:

```javascript
Reflect.get()
Reflect.set()
Reflect.apply()
//
```

你可能已经注意到了，Reflect 下的方法与 Proxy 的拦截器方
法名字相同，其实这不是偶然。任何在 Proxy 的拦截器中能够找到的
方法，都能够在 Reflect 中找到同名函数，那么这些函数的作用是什
么呢？其实它们的作用一点儿都不神秘。拿 Reflect.get 函数来
说，它的功能就是提供了访问一个对象属性的默认行为，例如下面两
个操作是等价的：

```javascript
const obj = {foo: 1}
// 直接读取
console.log(obj.foo) // 1
// 使用 Reflect.get 读取
console.log(Reflect.get(obj, 'foo')) // 1
```

可能有人会产生疑问：既然操作等价，那么它存在的意义是什么呢？实际上 Reflect.get 函数还能接收第三个参数，即指定接收者
receiver，你可以把它理解为函数调用过程中的 this，例如：

```javascript
const obj = {foo: 1}
console.log(Reflect.get(obj, 'foo', {foo: 2})) // 输出的是 2 而不是1
```

在这段代码中，我们指定第三个参数 receiver 为一个对象 {
foo: 2 }，这时读取到的值是 receiver 对象的 foo 属性值。实际
上，Reflect.* 方法还有很多其他方面的意义，但这里我们只关心并
讨论这一点，因为它与响应式数据的实现密切相关。为了说明问题，
回顾一下在上一节中实现响应式数据的代码：

```javascript
const obj = {foo: 1}
const p = new Proxy(obj, {
    get(target, key) {
        track(target, key)
        // 注意，这里我们没有使用 Reflect.get 完成读取
        return target[key]
    },
    set(target, key, newVal) {
        // 这里同样没有使用 Reflect.set 完成设置
        target[key] = newVal
        trigger(target, key)
    }
})
```

这是上一章中用来实现响应式数据的最基本的代码。在 get 和 set 拦截函数中，我们都是直接使用原始对象 target
来完成对属性的读取和设置操作的，其中原始对象 target 就是上述代码中的 obj对象。

那么这段代码有什么问题吗？我们借助 effect 让问题暴露出来。首先，我们修改一下 obj 对象，为它添加 bar 属性：

```javascript
const obj = {
    foo: 1,
    get bar() {
        return this.foo
    }
}
```

可以看到，bar 属性是一个访问器属性，它返回了 this.foo 属性的值。接着，我们在 effect 副作用函数中通过代理对象 p 访问 bar 属性：

```javascript
effect(() => {
    console.log(p.bar) // 1
})
```

我们来分析一下这个过程发生了什么。当 effect 注册的副作用
函数执行时，会读取 p.bar 属性，它发现 p.bar 是一个访问器属
性，因此执行 getter 函数。由于在 getter 函数中通过 this.foo
读取了 foo 属性值，因此我们认为副作用函数与属性 foo 之间也会建
立联系。当我们修改 p.foo 的值时应该能够触发响应，使得副作用函
数重新执行才对。然而实际并非如此，当我们尝试修改 p.foo 的值
时：

```javascript
p.foo++
```

副作用函数并没有重新执行，问题出在哪里呢？

实际上，问题就出在 bar 属性的访问器函数 getter 里：

```javascript
const obj = {
    foo: 1,
    get bar() {
        // 这里的 this 指向的是谁？
        return this.foo
    }
}
```

当我们使用 this.foo 读取 foo 属性值时，这里的 this 指向的是谁呢？我们回顾一下整个流程。首先，我们通过代理对象 p 访问
p.bar，这会触发代理对象的 get 拦截函数执行：

```javascript
const p = new Proxy(obj, {
    get(target, key) {
        track(target, key)
        //注意，这里我们没有使用 Reflect.get 完成读取
        return target[key]
    },
    // 省略部分代码
})
```

在 get 拦截函数内，通过 target[key] 返回属性值。其中
target 是原始对象 obj，而 key 就是字符串 'bar'，所以
target[key] 相当于 obj.bar。因此，当我们使用 p.bar 访问 bar
属性时，它的 getter 函数内的 this 指向的其实是原始对象 obj，
这说明我们最终访问的其实是 obj.foo。很显然，在副作用函数内通
过原始对象访问它的某个属性是不会建立响应联系的，这等价于：

```javascript
 effect(() => {
    // obj 是原始数据，不是代理对象，这样的访问不能够建立响应联系
    obj.foo
})
```

因为这样做不会建立响应联系，所以出现了无法触发响应的问题。那么这个问题应该如何解决呢？这时 Reflect.get 函数就派上用场了。先给出解决问题的代码：

```javascript
const p = new Proxy(obj, {
    // 拦截读取操作，接收第三个参数 receiver
    get(target, key, receiver) {
        track(target, key)
        // 使用 Reflect.get 返回读取到的属性值
        return Reflect.get(target, key, receiver)
    },
    // 省略部分代码
})
```

如上面的代码所示，代理对象的 get 拦截函数接收第三个参数receiver，它代表谁在读取属性，例如：

```javascript
 p.bar // 代理对象 p 在读取 bar 属性
```

当我们使用代理对象 p 访问 bar 属性时，那么 receiver 就是
p，你可以把它简单地理解为函数调用中的 this。接着关键的一步发
生了，我们使用 Reflect.get(target, key, receiver) 代替
之前的 target[key]，这里的关键点就是第三个参数 receiver。
我们已经知道它就是代理对象 p，所以访问器属性 bar 的 getter 函
数内的 this 指向代理对象 p：

```javascript
const obj = {
    foo: 1,
    get bar() {
        // 现在这里的 this 为代理对象 p
        return this.foo
    }
}
```

可以看到，this 由原始对象 obj 变成了代理对象 p。很显然，这
会在副作用函数与响应式数据之间建立响应联系，从而达到依赖收集
的效果。如果此时再对 p.foo 进行自增操作，会发现已经能够触发副
作用函数重新执行了。

正是基于上述原因，后文讲解中将统一使用 Reflect.* 方法

## JavaScript 对象及 Proxy 的工作原理

我们经常听到这样的说法：“JavaScript 中一切皆对象。”那么，到
底什么是对象呢？这个问题需要我们查阅 ECMAScript 规范才能得到答
案。实际上，根据 ECMAScript 规范，在 JavaScript 中有两种对象，其
中一种叫作常规对象（ordinary object），另一种叫作异质对象
（exotic object）。这两种对象包含了 JavaScript 世界中的所有对象，任
何不属于常规对象的对象都是异质对象。那么到底什么是常规对象，
什么是异质对象呢？这需要我们先了解对象的内部方法和内部槽。

我们知道，在 JavaScript 中，函数其实也是对象。假设给出一个对
象 obj，如何区分它是普通对象还是函数呢？实际上，在 JavaScript
中，对象的实际语义是由对象的内部方法（internal method）指定的。
所谓内部方法，指的是当我们对一个对象进行操作时在引擎内部调用
的方法，这些方法对于 JavaScript 使用者来说是不可见的。举个例子，
当我们访问对象属性时：

```javascript
obj.foo
```

引擎内部会调用 `Get` 这个内部方法来读取属性值。这里补充说明一下，在 ECMAScript 规范中使用 `xxx`
来代表内部方法或内部槽。当然，一个对象不仅部署了 `Get`这个内部方法，以下列出了规范要求的所有必要的内部方法。

| 内部方法            |                                                                                            描述                                                                                             |
| ------------------- | :-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| `GetPrototypeOf`    |                                                                    查明为该对象提供继承属性的对象，null 代表没有继承属性                                                                    |
| `SetPrototypeOf`    |                                  将该对象与提供继承属性的另一个对象相关联。传递 null 表示没有继承属性，返回 true 表示操作成功完成，返回 false 表示操作失败                                  |
| `IsExtensible`      |                                                                              查明是否允许向该对象添加其他属性                                                                               |
| `PreventExtensions` |                                                       控制能否向该对象添加新属性。如果操作成功则返回 true，如果操作失败 则返回 false                                                        |
| `GetOwnProperty`    |                                                   返回该对象自身属性的描述符，其键为 propertyKey，如果不存在这样的属性，则返回 undefined                                                    |
| `DefineOwnProperty` |               创建或更改自己的属性，其键为propertyKey，以具有由PropertyDescriptor 描述的状态。如果该属性已成功创建或更新，则返回true；如果无法创建或更新该属性，则返回 false                |
| `HasProperty`       |                                                         返回一个布尔值，指示该对象是否已经拥有键为 propertyKey 的自己的或继承的属性                                                         |
| `Get`               |                                 从该对象返回键为 propertyKey 的属性的值。如果必须运行 ECMAScript代码来检索属性值，则在运行代码时使用 Receiver 作为 this 值                                  |
| `Set`               | 将键值为 propertyKey 的属性的值设置为 value。如果必须运行ECMAScript 代码来设置属性值，则在运行代码时使用 Receiver 作为this 值。如果成功设置了属性值，则返回 true；如果无法设置，则返回false |
| `Delete`            |                            从该对象中删除属于自身的键为propertyKey 的属性。如果该属性未被删除并且仍然存在，则返回false；如果该属性已被删除或不存在，则返回 true                             |
| `OwnPropertyKeys`   |                                                                          返回一个 List，其元素都是对象自身的属性键                                                                          |

包括 `Get` 在内，一个对象必须部署 11 个必要的内部方法。还有两个额外的必要内部方法 ：`Call` 和 `Construct`

| 内部方法    |                                                                                                    描述                                                                                                    |
| ----------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| `Call`      |                                                           将运行的代码与 this 对象关联。由函数调用触发。该内部方法的参数是一个 this 值和参数列表                                                           |
| `Construct` | 创建一个对象。通过 new 运算符或 super 调用触发。该内部方法的第一个参数是一个 List，该 List 的元素是构造函数调用或 super 调用的参数，第二个参数是最初应用new 运算符的对象。实现该内部方法的对象称为构造函数 |

如果一个对象需要作为函数调用，那么这个对象就必须部署内部
方法 `Call`。现在我们就可以回答前面的问题了：如何区分一个
对象是普通对象还是函数呢？一个对象在什么情况下才能作为函数调
用呢？答案是，通过内部方法和内部槽来区分对象，例如函数对象会
部署内部方法 `Call`，而普通对象则不会。

内部方法具有多态性，这是什么意思呢？这类似于面向对象里多
态的概念。这就是说，不同类型的对象可能部署了相同的内部方法，
却具有不同的逻辑。例如，普通对象和 Proxy 对象都部署了
`Get` 这个内部方法，但它们的逻辑是不同的，普通对象部署的
`Get` 内部方法的逻辑是由 ECMA 规范的 10.1.8 节定义的，而
Proxy 对象部署的 `Get` 内部方法的逻辑是由 ECMA 规范的
10.5.8 节来定义的。

了解了内部方法，就可以解释什么是常规对象，什么是异质对象了。满足以下三点要求的对象就是常规对象:

- 对象必要的内部方法，必须使用 ECMA 规范 10.1.x 节给出的定义实现；
- 对于内部方法 `Call`，必须使用 ECMA 规范 10.2.1 节给出的定义实现；
- 对于内部方法 `Construct`，必须使用 ECMA 规范 10.2.2 节给出的定义实现。

而所有不符合这三点要求的对象都是**异质对象(外来对象)**。例如，由于Proxy 对象的内部方法 `Get` 没有使用 ECMA 规范的 10.1.8
节给出的定义实现，所以 Proxy 是一个异质对象。

现在我们对 JavaScript 中的对象有了更加深入的理解。接下来，我们就具体看看 Proxy 对象。既然 Proxy
也是对象，那么它本身也部署了上述必要的内部方法，当我们通过代理对象访问属性值时：

```javascript
const p = new Proxy(obj, {/* ... */})
p.foo
```

实际上，引擎会调用部署在对象 p 上的内部方法 `Get`。到这
一步，其实代理对象和普通对象没有太大区别。它们的区别在于对于
内部方法 `Get` 的实现，这里就体现了内部方法的多态性，即不同
的对象部署相同的内部方法，但它们的行为可能不同。具体的不同体
现在，如果在创建代理对象时没有指定对应的拦截函数，例如没有指
定 get() 拦截函数，那么当我们通过代理对象访问属性值时，代理对
象的内部方法 `Get` 会调用原始对象的内部方法 `Get` 来获取
属性值，这其实就是代理透明性质。

现在相信你已经明白了，创建代理对象时指定的拦截函数，实际上是用来自定义代理对象本身的内部方法和行为的，而不是用来指定被代理对象的内部方法和行为的。以下列出了
Proxy 对象部署的所有内部方法以及用来自定义内部方法和行为的拦截函数名字。

| 内部方法            |        处理器函数        |
| ------------------- | :----------------------: |
| `GetPrototypeOf`    |      getPrototypeOf      |
| `SetPrototypeOf`    |      setPrototypeOf      |
| `IsExtensible`      |       isExtensible       |
| `PreventExtensions` |    preventExtensions     |
| `GetOwnProperty`    | getOwnPropertyDescriptor |
| `DefineOwnProperty` |      defineProperty      |
| `HasProperty`       |           has            |
| `Get`               |           get            |
| `Set`               |           set            |
| `Delete`            |      deleteProperty      |
| `OwnPropertyKeys`   |         ownKeys          |
| `Call`              |          apply           |
| `Construct`         |        construct         |

当然，其中 `Call` 和 `Construct` 这两个内部方法只有当被代理的对象是函数和构造函数时才会部署。

当我们要拦截删除属性操作时，可以使用 deleteProperty 拦截函数实现：

```javascript
const obj = {foo: 1}
const p = new Proxy(obj, {
    deleteProperty(target, key) {
        return Reflect.deleteProperty(target, key)
    }
})

console.log(p.foo) // 1
delete p.foo
console.log(p.foo) // 未定义
```

这里需要强调的是，deleteProperty 实现的是代理对象 p
的内部方法和行为，所以为了删除被代理对象上的属性值，我们需要使用Reflect.deleteProperty(target, key) 来完成。

## 如何代理Object

从本节开始，我们将着手实现响应式数据。前面我们使用 get 拦
截函数去拦截对属性的读取操作。但在响应系统中，“读取”是一个很
宽泛的概念，例如使用 in 操作符检查对象上是否具有给定的 key 也
属于“读取”操作，如下面的代码所示

```javascript
 effect(() => {
    'foo' in obj
})
```

这本质上也是在进行“读取”操作。响应系统应该拦截一切读取操作，以便当数据变化时能够正确地触发响应。下面列出了对一个普通对象的所有可能的读取操作。

- 访问属性：obj.foo。
- 判断对象或原型上是否存在给定的 key：key in obj。
- 使用 for...in 循环遍历对象：for (const key in obj){}。

接下来，我们逐步讨论如何拦截这些读取操作。首先是对于属性的读取，例如 obj.foo，我们知道这可以通过 get 拦截函数实现：

```javascript
const obj = {foo: 1}

const p = new Proxy(obj, {
    get(target, key, receiver) {
        // 建立联系
        track(target, key)
        // 返回属性值
        return Reflect.get(target, key, receiver)
    },
})
```

in操作符的运行时逻辑：

![avatar](/Vue/images/第135页-29.png)

1. 让 lref 的值为 RelationalExpression 的执行结果。
2. 让 lval 的值为 ? GetValue(lref)。
3. 让 rref 的值为 ShiftExpression 的执行结果。
4. 让 rval 的值为 ? GetValue(rref)。
5. 如果 Type(rval) 不是对象，则抛出 TypeError 异常。
6. 返回 ? HasProperty(rval, ? ToPropertyKey(lval))

关键点在第 6 步，可以发现，in 操作符的运算结果是通过调用一个叫作 HasProperty 的抽象方法得到的。关于 HasProperty 抽象方法，可以在
ECMA-262 规范的 7.3.11 节中找到。

![avatar](/Vue/images/第136页-30.png)

1. 断言：Type(O) 是 Object。
2. 断言：IsPropertyKey(P) 是 true。
3. 返回 ? O.`HasProperty`(P)。

在第 3 步中，可以看到 HasProperty 抽象方法的返回值是通过调用对象的内部方法 `HasProperty` 得到的。它对应的拦截函数名叫
has，因此我们可以通过 has 拦截函数实现对 in 操作符的代理：

```javascript
const obj = {foo: 1}
const p = new Proxy(obj, {
    has(target, key) {
        track(target, key)
        return Reflect.has(target, key)
    }
})
```

这样，当我们在副作用函数中通过 in 操作符操作响应式数据时，就能够建立依赖关系：

```javascript
effect(() => {
    'foo' in p // 将会建立依赖关系
})
```

再来看看如何拦截 for...in 循环。上文列出的是一个对象的所有基本语义方法，也就是说，任何操作其实都是由这些基本语义方法及其组合实现的，
for...in 循环也不例外。为了搞清楚
for...in循环依赖哪些基本语义方法，还需要看规范。

![avatar](/Vue/images/第137页-31.png)

第 6 步描述的内容如下。

如果 iterationKind 是枚举（enumerate），则

- a. 如果 exprValue 是 undefined 或 null，那么 i. 返回 Completion { `Type`: break,`Value`: empty, `Target`: empty }。
- b. 让 obj 的值为 ! ToObject(exprValue)。
- c. 让 iterator 的值为 ? EnumerateObjectProperties(obj)。
- d. 让 nextMethod 的值为 ! GetV(iterator,"next")。
- e. 返回 Record{ `Iterator`: iterator,`NextMethod`: nextMethod, `Done`: false }。

仔细观察第 6 步的第 c 子步骤：

让 iterator 的值为 ? EnumerateObjectProperties(obj)。

其中的关键点在于 EnumerateObjectProperties(obj)。这里的 EnumerateObjectProperties 是一个抽象方法，该方法返回一个迭代器对象，规范的
14.7.5.9
节给出了满足该抽象方法的示例实现，如下面的代码所示：

```javascript
function* EnumerateObjectProperties(obj) {
    const visited = new Set()
    for (const key of Reflect.ownKeys(obj)) {
        if (typeof key === "symbol") continue
        const desc = Reflect.getOwnPropertyDescriptor(obj, key)
        if (desc) {
            visited.add(key)
            if (desc.enumerable) yield key
        }
    }
    const proto = Reflect.getPrototypeOf(obj)
    if (proto === null) return
    for (const protoKey of EnumerateObjectProperties(proto)) {
        if (!visited.has(protoKey)) yield protoKey
    }
}
```

可以看到，该方法是一个 generator 函数，接收一个参数
obj。实际上，obj 就是被 for...in 循环遍历的对象，其关键点在
于使用 Reflect.ownKeys(obj) 来获取只属于对象自身拥有的键。
有了这个线索，如何拦截 for...in 循环的答案已经很明显了，我们
可以使用 ownKeys 拦截函数来拦截 Reflect.ownKeys 操作：

```javascript
const obj = {foo: 1}
const ITERATE_KEY = Symbol()
const p = new Proxy(obj, {
    ownKeys(target) {
        // 将副作用函数与 ITERATE_KEY 关联
        track(target, ITERATE_KEY)
        return Reflect.ownKeys(target)
    }
})
```

如上面的代码所示，拦截 ownKeys 操作即可间接拦截 for...in
循环。但相信大家已经注意到了，我们在使用 track 函数进行追踪的
时候，将 ITERATE_KEY 作为追踪的 key，为什么这么做呢？这是因
为 ownKeys 拦截函数与 get/set 拦截函数不同，在 set/get 中，我
们可以得到具体操作的 key，但是在 ownKeys 中，我们只能拿到目标
对象 target。这也很符合直觉，因为在读写属性值时，总是能够明确
地知道当前正在操作哪一个属性，所以只需要在该属性与副作用函数
之间建立联系即可。而 ownKeys 用来获取一个对象的所有属于自己的
键值，这个操作明显不与任何具体的键进行绑定，因此我们只能够构
造唯一的 key 作为标识，即 ITERATE_KEY。

既然追踪的是 ITERATE_KEY，那么相应地，在触发响应的时候也应该触发它才行:

```javascript
 trigger(target, ITERATE_KEY)
```

但是在什么情况下，对数据的操作需要触发与 ITERATE_KEY 相关联的副作用函数重新执行呢？为了搞清楚这个问题，我们用一段代码来说明。假设副作用函数内有一段
for...in 循环：

```javascript
const obj = {foo: 1}
const p = new Proxy(obj, {/* ... */})

effect(() => {
    // for...in 循环
    for (const key in p) {
        console.log(key) // foo
    }
})
```

副作用函数执行后，会与 ITERATE_KEY 之间建立响应联系，接下来我们尝试为对象 p 添加新的属性 bar：

```javascript
p.bar = 2
```

由于对象 p 原本只有 foo 属性，因此 for...in 循环只会执行一
次。现在为它添加了新的属性 bar，所以 for...in 循环就会由执行
一次变成执行两次。也就是说，当为对象添加新属性时，会对
for...in 循环产生影响，所以需要触发与 ITERATE_KEY 相关联的
副作用函数重新执行。但目前的实现还做不到这一点。当我们为对象 p
添加新的属性 bar 时，并没有触发副作用函数重新执行，这是为什么
呢？我们来看一下现在的 set 拦截函数的实现：

```javascript
const p = new Proxy(obj, {
    // 拦截设置操作
    set(target, key, newVal, receiver) {
        // 设置属性值
        const res = Reflect.set(target, key, newVal, receiver)
        // 把副作用函数从桶里取出并执行
        trigger(target, key)

        return res
    },
    // 省略其他拦截函数
})
```

当为对象 p 添加新的 bar 属性时，会触发 set 拦截函数执行。此
时 set 拦截函数接收到的 key 就是字符串 'bar'，因此最终调用
trigger 函数时也只是触发了与 'bar' 相关联的副作用函数重新执
行。但根据前文的介绍，我们知道 for...in 循环是在副作用函数与
ITERATE_KEY 之间建立联系，这和 'bar' 一点儿关系都没有，因此
当我们尝试执行 p.bar = 2 操作时，并不能正确地触发响应。

弄清楚了问题在哪里，解决方案也就随之而来了。当添加属性时，我们将那些与 ITERATE_KEY 相关联的副作用函数也取出来执行就可以了：

```javascript
function trigger(target, key) {
    const depsMap = bucket.get(target)
    if (!depsMap) return
    // 取得与 key 相关联的副作用函数
    const effects = depsMap.get(key)
    // 取得与 ITERATE_KEY 相关联的副作用函数
    const iterateEffects = depsMap.get(ITERATE_KEY)

    const effectsToRun = new Set()
    // 将与 key 相关联的副作用函数添加到 effectsToRun
    effects && effects.forEach(effectFn => {
        if (effectFn !== activeEffect) {
            effectsToRun.add(effectFn)
        }
    })
    // 将与 ITERATE_KEY 相关联的副作用函数也添加到 effectsToRun
    iterateEffects && iterateEffects.forEach(effectFn => {
        if (effectFn !== activeEffect) {
            effectsToRun.add(effectFn)
        }
    })

    effectsToRun.forEach(effectFn => {
        if (effectFn.options.scheduler) {
            effectFn.options.scheduler(effectFn)
        } else {
            effectFn()
        }
    })
}
```

如以上代码所示，当 trigger 函数执行时，除了把那些直接与具体操作的 key 相关联的副作用函数取出来执行外，还要把那些与ITERATE_KEY
相关联的副作用函数取出来执行。

但对于添加新的属性来说，这么做没有什么问题，但如果仅仅修改已有属性的值，而不是添加新属性，那么问题就来了。看如下代码：

```javascript
const obj = {foo: 1}
const p = new Proxy(obj, {/* ... */})

effect(() => {
    // for...in 循环
    for (const key in p) {
        console.log(key) // foo
    }
})
```

当我们修改 p.foo 的值时：

```javascript
obj.foo = 2
```

与添加新属性不同，修改属性不会对 for...in 循环产生影响。
因为无论怎么修改一个属性的值，对于 for...in 循环来说都只会循
环一次。所以在这种情况下，我们不需要触发副作用函数重新执行，
否则会造成不必要的性能开销。然而无论是添加新属性，还是修改已
有的属性值，其基本语义都是 `Set`，我们都是通过 set 拦截函数
来实现拦截的，如以下代码所示：

```javascript
const p = new Proxy(obj, {
    // 拦截设置操作
    set(target, key, newVal, receiver) {
        // 设置属性值
        const res = Reflect.set(target, key, newVal, receiver)
        // 把副作用函数从桶里取出并执行
        trigger(target, key)

        return res
    },
    // 省略其他拦截函数
})
```

所以要想解决上述问题，当设置属性操作发生时，就需要我们在set 拦截函数内能够区分操作的类型，到底是添加新属性还是设置已有属性:

```javascript
 const p = new Proxy(obj, {
    // 拦截设置操作
    set(target, key, newVal, receiver) {
        // 如果属性不存在，则说明是在添加新属性，否则是设置已有属性
        const type = Object.prototype.hasOwnProperty.call(target,
            key) ? 'SET' : 'ADD'

        // 设置属性值
        const res = Reflect.set(target, key, newVal, receiver)

        // 将 type 作为第三个参数传递给 trigger 函数
        trigger(target, key, type)

        return res
    },
    // 省略其他拦截函数
})
```

如以上代码所示，我们优先使用
Object.prototype.hasOwnProperty 检查当前操作的属性是否已
经存在于目标对象上，如果存在，则说明当前操作类型为 'SET'，即
修改属性值；否则认为当前操作类型为 'ADD'，即添加新属性。最
后，我们把类型结果 type 作为第三个参数传递给 trigger 函数。

在 trigger 函数内就可以通过类型 type 来区分当前的操作类型，并且只有当操作类型 type 为 'ADD' 时，才会触发与ITERATE_KEY
相关联的副作用函数重新执行，这样就避免了不必要的性能损耗：

```javascript
function trigger(target, key, type) {
    const depsMap = bucket.get(target)
    if (!depsMap) return
    const effects = depsMap.get(key)

    const effectsToRun = new Set()
    effects && effects.forEach(effectFn => {
        if (effectFn !== activeEffect) {
            effectsToRun.add(effectFn)
        }
    })
    console.log(type, key)
    // 只有当操作类型为 'ADD' 时，才触发与 ITERATE_KEY 相关联的副作用函数重新执行
    if (type === 'ADD') {
        const iterateEffects = depsMap.get(ITERATE_KEY)
        iterateEffects && iterateEffects.forEach(effectFn => {
            if (effectFn !== activeEffect) {
                effectsToRun.add(effectFn)
            }
        })
    }

    effectsToRun.forEach(effectFn => {
        if (effectFn.options.scheduler) {
            effectFn.options.scheduler(effectFn)
        } else {
            effectFn()
        }
    })
}
```

关于对象的代理，还剩下最后一项工作需要做，即删除属性操作的代理：

```javascript
 delete p.foo
```

如何代理 delete 操作符呢？还是看规范，规范的 13.5.1.2 节中明确定义了 delete 操作符的行为。

![avatar](/Vue/images/第145页-32.png)

的第 5 步描述的内容如下。

如果 IsPropertyReference(ref) 是 true，那么

- a. 断言：! IsPrivateReference(ref) 是 false。
- b. 如果 IsSuperReference(ref) 也是 true，则抛出 ReferenceError 异常。
- c. 让 baseObj 的值为 ! ToObject(ref,`Base`)。
- d. 让 deleteStatus 的值为 ? baseObj.`Delete`(ref.`ReferencedName`)。
- e. 如果 deleteStatus 的值为 false 并且 ref.`Strict` 的值是 true，则抛出 TypeError 异常。
- f. 返回 deleteStatus。

由第 5 步中的 d 子步骤可知，delete 操作符的行为依赖`Delete`内部方法。接着上文对应表，该内部方法可以使用`deleteProperty`拦截：

```javascript
 const p = new Proxy(obj, {
    deleteProperty(target, key) {
        // 检查被操作的属性是否是对象自己的属性
        const hadKey = Object.prototype.hasOwnProperty.call(target, key)
        // 使用 Reflect.deleteProperty 完成属性的删除
        const res = Reflect.deleteProperty(target, key)

        if (res && hadKey) {
            // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新
            trigger(target, key, 'DELETE')
        }

        return res
    }
})
```

如以上代码所示，首先检查被删除的属性是否属于对象自身，然
后调用 Reflect.deleteProperty 函数完成属性的删除工作，只有
当这两步的结果都满足条件时，才调用 trigger 函数触发副作用函数
重新执行。需要注意的是，在调用 trigger 函数时，我们传递了新的
操作类型 'DELETE'。由于删除操作会使得对象的键变少，它会影响
for...in 循环的次数，因此当操作类型为 'DELETE' 时，我们也应
该触发那些与 ITERATE_KEY 相关联的副作用函数重新执行：

```javascript
 function trigger(target, key, type) {
    const depsMap = bucket.get(target)
    if (!depsMap) return
    const effects = depsMap.get(key)

    const effectsToRun = new Set()
    effects && effects.forEach(effectFn => {
        if (effectFn !== activeEffect) {
            effectsToRun.add(effectFn)
        }
    })

    // 当操作类型为 ADD 或 DELETE 时，需要触发与 ITERATE_KEY 相关联的副作用函数重新执行
    if (type === 'ADD' || type === 'DELETE') {
        const iterateEffects = depsMap.get(ITERATE_KEY)
        iterateEffects && iterateEffects.forEach(effectFn => {
            if (effectFn !== activeEffect) {
                effectsToRun.add(effectFn)
            }
        })
    }

    effectsToRun.forEach(effectFn => {
        if (effectFn.options.scheduler) {
            effectFn.options.scheduler(effectFn)
        } else {
            effectFn()
        }
    })
}
```

在这段代码中，我们添加了 type === 'DELETE' 判断，使得删除属性操作能够触发与 ITERATE_KEY 相关联的副作用函数重新执行。

## 合理地触发响应

上一节中，我们从规范的角度详细介绍了如何代理对象，在这个过程中，处理了很多边界条件。例如，我们需要明确知道操作的类型是'AD0'
还是'SET'，抑或是其他操作类型，从而正确地触发响应。但想要合理地触发响应，还有许多工作要做。
首先，我们来看要面临的第一个问题，即当值没有发生变化时，应该不需要触发响应才对:

```javascript
const obj = {foo: 1}
const p = new Proxy(obj, {})

effect(() => {
    console.log(p.foo)
})

// 设置p.foo的值，但值没有变化
p.foo = 1
```

如上面的代码所示，p.foo的初始值为1,当为p.foo设置新的值时，如果值没有发生变化，则不需要触发响应。为了满足需求，我们需要修改
set拦截函数的代码，在调用trigger函数触发响应之前，需要检查值是否真的发生了变化:

```javascript
const p = new Proxy(obj, {
    set(target, key, newValue, receiver) {
        const oldValue = target[key]
        const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
        const res = Reflect.set(target, key, newValue, receiver)
        if (oldValue !== newValue) {
            trigger(target, key, type)
        }
        return res
    }
})
```

如上面的代码所示，我们在set拦截函数内首先获取旧值aldval，接着比较新值与旧值，只有当它们不全等的时候才触发响应。现在，如果我们再次测试本节开头的例子，会发现重新设置相同的值已经不会触发响应了。
然而，仅仅进行全等比较是有缺陷的，这体现在对NaN的处理上。我们知道NaN与NaN进行全等比较总会得到 false:

```javascript
NaN === NaN // false
NaN !== NaN // true
```

换句话说、如果p.foo的初始值是NaN，并且后续又为其设置了NaN作为新值，那么仅仅进行全等比较的缺陷就暴露了:

```javascript
const obj = {foo: NaN}
const p = new Proxy(obj, {})

effect(() => {
    console.log(p.foo)
})

// 依旧会触发响应
p.foo = NaN
```

这仍然会触发响应，并导致不必要的更新。为了解决这个问题，我们需要再加一个条件，即在新值和旧值不全等的情况下，要保证它们都不是NaN:

```javascript
const p = new Proxy(obj, {
    set(target, key, newValue, receiver) {
        const oldValue = target[key]
        const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
        const res = Reflect.set(target, key, newValue, receiver)
        if (oldValue !== newValue && (oldValue === oldValue || newValue === newValue)) {
            trigger(target, key, type)
        }
        return res
    }
})
```

这样我们就解决了NaN的问题。但想要合理地触发响应，仅仅处理关于NaN的问题还不够。接下来，我们讨论一种从原型上继承属性的情况。为了后续讲解方便，我们需要封装一个reactive函数，该函数接收一个对象作为参数，并返回为其创建的响应式数据:

```javascript
function reactive(obj) {
    return new Proxy(obj, {})
}
```

可以看到，reactive函数只是对Proxy进行了一层封装。接下来，我们基于reactive创建一个例子:

```javascript
const obj = {}
const proto = {bar: 1}
const child = reactive(obj)
const parent = reactive(proto)
Object.setPrototypeOf(child, parent)

effect(() => {
    console.log(child, bar) // 1
})

child.bar = 2 // 会导致副作用函数重新执行两次
```

观察如上代码，我们定义了空对象obj和对象proto，分别为二者创建了对应的响应式数据child和parent,并且使用object.setPrototypeof
方法将parent设置为child的原型。接着在副作用函数内访问child.bar的值。从代码中可以看出，child本身并没有bar属性，因此当访问child.bar时，
值是从原型上继承而来的。但无论如何，既然child是响应式数据，那么它与副作用函数之间就会建立联系，因此当我们执行child.bar=2时，期望副作用函数会重新执行。
但如果你尝试运行上面的代码，会发现副作用函数不仅执行了，还执行了两次，这会造成不必要的更新。
为了搞清楚问题的原因，我们需要逐步分析整个过程。当在副作用函数中读取child.bar的值时，会触发child代理对象的get拦截函数。我们知道，在拦截函数内是使用Reflect.get(
target,key，receiver)来得到最终结果的，对应到上例，这句话相当于:

```javascript
Reflect.get(obj, 'bar', receiver)
```

这其实是实现了通过obj.bar来访问属性值的默认行为。也就是说，引擎内部是通过调用obj对象所部署的[[Get]]
内部方法来得到最终结果的，因此我们有必要查看规范10.1.8.1节来了解[[Get]]内部方法的执行流程。

![avatar](/Vue/images/第151页-33.png)

```text
3.如果desc是undefined,那么:
  a.让 parent 的值为?0.[[GetPrototypeOf]]()。
  b.如o果parent 是 null,则返回 undefined.
  c. 返回? parent.[[Get]](P,Receiver)。
```

第3步中，我们能够了解到非常关键的信息，即如果对象自身不存在该属性，那么会获取对象的原型，并调用原型的[[Get]]
方法得到最终结果。对应到上例中，当读取child.bar属性值时，由于child代理的对象obj自身没有bar属性，因此会获取对象obj的原型，也就是parent对象，所以最终得到的实际上是parent.bar的值。
但是大家不要忘了，parent本身也是响应式数据，因此在副作用函数中访问parent.bar的值时，会导致副作用函数被收集，从而也建立响应联系。所以我们能够得出一个结论，即child.bar和parent.bar都与副作用函数建立了响应联系。

但这仍然解释不了为什么当设置child.bar的值时，会连续触发两次副作用函数执行，所以接下来我们需要看看当设置操作发生时的具体执行流程。
我们知道，当执行child.bar=2时，会调用child代理对象的set拦截函数。
同样，在set拦截函数内，我们使用Reflect.set(target，key,newVal,receiver)
来完成默认的设置行为，即引擎会调用obj对象部署的[[Set]]
内部方法，根据规范的10.1.9.2节可知[[Set]]内部方法的执行流程，

![avatar](/Vue/images/第152页-34.png)

```text
2.如果 ownDesc 是 undefined,那么
  a.让 parent 的值为0.[[GetPrototypeOf]]()。
  b.如果parent不是null,则
    1.返回?parent.[[Set]](P,V,Receiver);
  C.否则
    1.将ownDesc 设置为{[[Value]]:undefined,[[Writable]]:true, [[Enumerable]: true, [[Configurable]]:true }
```

由第2步可知，如果设置的属性不存在于对象上，那么会取得其原型，并调用原型的[[Set]方法，也就是parent的[[Set]]
内部方法。由于parent是代理对象，所以这就相当于执行了它的set拦截函数。
换句话说，虽然我们操作的是child.bar，但这也会导致parent代理对象的set拦截函数被执行。
前面我们分析过，当读取child.bar的值时，副作用函数不仅会被child.bar收集，也会被parent.bar收集。
所以当parent代理对象的set拦截函数执行时，就会触发副作用函数重新执行，这就是为什么修改child.bar的值会导致副作用函数重新执行两次。

接下来，我们需要思考解决方案。思路很简单，既然执行两次，那么只要屏蔽其中一次不就可以了吗?我们可以把由parent.bar触发的那次副作用函数的重新执行屏蔽。
怎么屏蔽呢?我们知道，两次更新是由于set拦截函数被触发了两次导致的，所以只要我们能够在set拦截函数内区分这两次更新就可以了。当我们设置child.bar的值时，会执行child代理对象的set拦截数:

```javascript
// child的set拦截函数
set(target, key, value, receiver)
{
    // target 是原始对象obj
    // receiver 是代理对象child
}
```

此时的target是原始对象obj,recetiver是代理对象child,我们发现receiver 其实就是 target 的代理对象

但由于obj上不存在bar 属性,所以会取得obj的原型parent,并执行parent代理对象的 set拦截函数:

```javascript
// parent的set拦截函数
set(target, key, value, receiver)
{
    // target 是原始对象proto
    // receiver 是代理对象child
}
```

我们发现，当parent代理对象的 set拦截函数执行时，此时 target是始对象proto，而receiver 仍然是代理对象 chtld，而不再是
target的代理对象。通过这个特点，我们可以看到target和receiver的区别。由于我们最初设置的是chtld.bar的值，所以无论在什么情况下,receiver都是child、而
target则是变化的。
根据这个区别，我们很容易想到解决办法，只需要判断receiver是否是target的代理对象即可。只有当receiver是target的代理对象时才触发更新，这样就能够屏蔽由原型引起的更新了。

所以接下来的问题变成了如何确定receiver 是不是target 的代理对象，这需要我们为get拦截函数添加一个能力，如以下代码所示:

```javascript
function reactive(obj) {
    return new Proxy(obj, {
        get(target, key, receiver) {
            if (key === 'raw') {
                return target
            }
            track(target, key)
            return Reflect.get(target, key, receiver)
        }
    })
}
```

我们增加了一段代码，它实现的功能是，代理对象可以通过raw属性读取原始数据，例如:

```javascript
child.raw === obj // true
parent.raw === proto // true
```

有了它，我们就能够在set拦截函数中判断receiver 是不是target的代理对象了:

```javascript
function reactive(obj) {
    return new Proxy(obj, {
        set(target, key, newValue, receiver) {
            const oldValue = target[key]
            const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
            const res = Reflect.set(target, key, newValue, receiver)

            // target === receiver.raw 说明 receiver 就是 target 的代理对象
            if (target === receiver.raw) {
                if (oldValue !== newValue && (oldValue === oldValue || newValue === newValue)) {
                    trigger(target, key, type)
                }
            }
            return res
        }
    })
}
```

如以上代码所示，我们新增了一个判断条件，只有当receiver是target的代理对象时才触发更新，这样就能屏蔽由原型引起的更新，从而避免不必要的更新操作。

## 浅响应与深响应

本节中我们将介绍reactive与shallowReactive的区别,即深响应和浅响应的区别。实际上我们目前所实现的reactive是浅响应的。拿如下代码来说:

```javascript
const obj = reactive({foo: {bar: 1}})

effect(() => {
    console.log(obj.foo.bar)
})

// 修改obj.foo.bar 的值，并不能触发响应
obj.foo.bar = 2
```

首先，创建obj代理对象，该对象的foo属性值也是一个对象，即{bar:1}。接着，在副作用函数内访问obj.foo.bar的值。但是我们发现，后续对obj.foo.bar
的修改不能触发副作用函数重新执行，这是为什么呢?来看一下现在的实现:

```javascript
function reactive(obj) {
    return new Proxy(obj, {
        get(target, key, receiver) {
            if (key === 'raw') {
                return target
            }
            track(target, key)
            return Reflect.get(target, key, receiver)
        }
    })
}
```

由上面这段代码可知，当我们读取obj.foo.bar时，首先要读取obj.foo的值。这里我们直接使用Reflect.get函数返回obj.foo的结果。
由于通过Reflect.get得到obj.foo的结果是一个普通对象，即{bar:
1},它并不是一个响应式对象，所以在副作用函数中访问obj.foo.bar时，是不能建立响应联系的。要解决这个问题，我们需要对Reflect.get返回的结果做一层包装:

```javascript
function reactive(obj) {
    return new Proxy(obj, {
        get(target, key, receiver) {
            if (key === 'raw') {
                return target
            }
            track(target, key)
            // 得到原始值结果
            const res = Reflect.get(target, key, receiver)
            if (typeof res === 'object' && res !== null) {
                return reactive(res)
            }
            return res
        }
    })
}
```

如上面的代码所示，当读取属性值时，我们首先检测该值是否是对象，如果是对象，则递归地调用reactive函数将其包装成响应式数据并返回。
这样当使用obj.foo读取foo属性值时，得到的就会是一个响应式数据，因此再通过obj.foo.bar读取bar属性值时，自然就会建立响应联系。
这样，当修改obj.foo.bar的值时，就能够触发副作用函数重新执行了。
然而，并非所有情况下我们都希望深响应，这就催生了shallowReactive，即浅响应。所谓浅响应，指的是只有对象的第一层属性是响应的，例如:

```javascript
const obj = shallowReactive({foo: {bar: 1}})

effect(() => {
    console.log(obj.foo.bar)
})

// obj.foo 是响应的，可以触发副作用函数重新执行
obj.foo = {bar: 2}
// obj.foo.bar 不是响应的，不能触发副作用函数重新执行
obj.foo.bar = 3
```

在这个例子中，我们使用shallowReactive函数创建了一个浅响应的代理对象obj。可以发现，只有对象的第一层属性是响应的，第二层及更深层次的属性则不是响应的。实现此功能并不难，如下面的代码所示:

```javascript
// 封装createReacttve函数,接状一个参数tsShallow,代表是否为浅响应、默认为false、即非浅响应
function createReactive(obj, isShallow = false) {
    return new Proxy(obj, {
        //拦截读取操作
        get(target, key, receiver) {
            if (key === 'raw') {
                return target
            }
            const res = Reflect.get(target, key, receiver)
            // 如果是浅响应,则直接返回原始值
            if (isShallow) {
                return res
            }
            track(target, key)
            if (typeof res === 'object' && res !== null) {
                return reactive(res)
            }
            return res
        }
    })
}
```

在上面这段代码中，我们把对象创建的工作封装到一个新的函数createReactive 中。该函数除了接收原始对象obj之外，还接收参数
isShallow，它是一个布尔值，代表是否创建浅响应对象。
默认情况下，isShallow的值为false，代表创建深响应对象。这里需要注意的是，当读取属性操作发生时，在get拦截函数内如果发现是浅响应的，那么直接返回原始数据即可。
有了createReactive函数后,我们就可以使用它轻松地实现reactive以及shallowReactive函数了:

```javascript
function reactive(obj) {
    return createReactive(obj)
}

function shallowReactive(obj) {
    return createReactive(obj, true)
}
```

## 只读和浅只读

我们希望一些数据是只读的，当用户尝试修改只读数据时，会收到一条警告信息。这样就实现了对数据的保护，例如组件接收到的props
对象应该是一个只读数据。这时就要用到接下来要讨论的readonly函数，它能够将一个数据变成只读的:

```javascript
const obj = readonly({foo: 1})
// 尝试修改数据,会得到警告
obj.foo = 2
```

只读本质上也是对数据对象的代理，我们同样可以使用createReactive函数来实现。如下面的代码所示，我们为createReactive函数增加第三个参数isReadonly:

```javascript
// 增加第三个参数isReadonly,代表是否只读，默认为false，即非只读
function createReactive(obj, isShallow = false, isReadonly = false) {
    return new Proxy(obj, {
        // 拦截设置操作
        set(target, key, newValue, receiver) {
            // 如果是只读的，则打印警告信息并返回
            if (isReadonly) {
                console.warn(`属性 $[key] 是只读的'`)
                return true
            }
            const oldValue = target[key]
            const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
            const res = Reflect.set(target, key, newValue, receiver)
            if (target === receiver.raw) {
                if (oldValue !== newValue && (oldValue === oldValue || newValue === newValue)) {
                    trigger(target, key, type)
                }
            }
            return res
        },
        deleteProperty(target, key) {
            // 如果是只读的、则打印警告信息并返回
            if (isReadonly) {
                console.warn(`属性 $[key] 是只读的'`)
                return true
            }
            const hadKey = Object.prototype.hasownproperty.call(target, key)
            const res = Reflect.deleteProperty(target, key)
            if (res && hadkey) {
                trigger(target, key, 'DELETE')
            }
            return res
        }
    })
}
```

在这段代码中，当使用createReactive创建代理对象时，可以通过第三个参数指定是否创建一个只读的代理对象。
同时，我们还修改了get拦截函数和deleteProperty拦截函数的实现、因为对于一个对象来说，只读意味着既不可以设置对象的属性值，也不可以删除对象的属性。
在这两个拦截函数中，我们分别添加了是否是只读的判断，一旦数据是只读的，则当这些操作发生 时，会打印警告信息，提示用户这是一个非法操作。
当然，如果一个数据是只读的，那就意味着任何方式都无法修改它。因此，没有必要为只读数据建立响应联系。
出于这个原因，当在副作用函数中读取一个只读属性的值时，不需要调用track函数追踪响应:

```javascript
const obj = readonly({foo: 1})
effect(() => {
    obj.foo//可以读取值，但是不需委在副作用函数与数据之间建立响应联系
})
```

为了实现该功能，我们需要修改get拦截函数的实现:

```javascript
function createReactive(obj, isShallow = false, isReadonly = false) {
    return new Proxy(obj, {
        // 拦截读取操作
        get(target, key, receiver) {
            if (key === 'raw') {
                return target
            }
            // 非只读的时候才需要建立响应联系
            if (!isReadonly) {
                track(target, key)
            }
            const res = Reflect.get(target, key, receiver)

            if (isShallow) {
                return res
            }

            if (typeof res === 'object' & res !== null) {
                return reactive(res)
            }

            return res
        }
    })
}
```

如上面的代码所示，在get拦截函数内检测isReadonly变量的值，判断是否是只读的，只有在非只读的情况下才会调用track函数建立响应联系。基于此，我们就可以实现readonly函数了:

```javascript
function readonly(obj) {
    return createReactive(obj, false, true /* 只读 */)
}
```

然而,上面实现的readonly函数更应该叫作shallowReadonly，因为它没有做到深只读:

```javascript
const obj = readonly({foo: {bar: 1}})
obj.foo.bar = 2 // 可以修改
```

所以为了实现深只读，我们还应该在get拦截函数内递归地调用readonly将数据包装成只读的代理对象，并将其作为返回值返回:

```javascript
function createReactive(obj, isShallow = false, isReadanly = false) {
    return new Proxy(obj, {
        get(target, key, receiver) {
            if (key === 'raw') {
                return target
            }
            if (!isReadanly) {
                track(target, key)
            }
            const res = Reflect.get(target, key, receiver)

            if (isShallow) {
                return res
            }

            if (typeof res === 'object' && res !== null) {
                // 如果数据为只读，则调用readonly对值进行包装
                return isReadanly ? readonly(res) : reactive(res)
            }
            return res
        }
    })
}
```

如上面的代码所示，我们在返回属性值之前，判断它是否是只读的，如果是只读的，则调用readonly函数对值进行包装，并把包装后的只读对象返回。
对于shallowReadonly，实际上我们只需要修改createReactive的第二个参数即可:

```javascript
function readonly(obj) {
    return createReactive(obj, false, true)
}

function shallowReadonly(obj) {
    return createReactive(obj, true, true)
}
```

如上面的代码所示，在shallowReadonly函数内调用createReactive函数创建代理对象时，第二个参数isShallow设置为true，这样就可以创建一个浅只读的代理对象了

## 代理数组

从本节开始，我们讲解如何代理数组。实际上，在JavaScript中，数组只是一个特殊的对象而已，因此想要更好地实现对数组的代理，就有必要了解相比普通对象，数组到底有何特殊之处。
在5.2节中，我们深人讲解了JavaScript中的对象。我们知道，在JavaScript中有两种对象:常规对象和异质对象。我们还讨论了两者的差异。
而本节中我们要介绍的数组就是一个异质对象，这是因为数组对象的[[DefineOwnProperty]]内部方法与常规对象不同。
换句话说，数组对象除了[[DefineOwnProperty]]
这个内部方法之外，其他内部方法的逻辑都与常规对象相同。因此，当实现对数组的代理时，用于代理普通对象的大部分代码可以继续使用，如下所示:

```javascript
const arr = reactive(['foo'])

effect(() => {
    console.log(arr[0])
})

arr[0] = 'bar' // 触发响应
```

上面这良代码能够按预期工作。实际上，当我们通过索引读取或设胃教组元素的值时,仰07对象的8比St拦截函数也会执行，因此我们不需要做任何额外的工作，就能够让数组索引的
取和设置操作是响应式的了。但对数组的操作与对普通对象的操作仍然存在不同，下面总结了所有对数组元索或属能约"读取"操作。

- 通过索引访问数组元素值:arr[0]。
- 访问数组的长度:arr.length。
- 把数组作为对象，使用for...in循环遍历。
- 使用for...of迭代遍历数组。
- 数组的原型方法，如 concat/join/every/some/find/findIndex/includes 等，以及其他所有不改变原数组的原型方法。

可以看到，对数组的读取操作要比普通对象丰富得多。我们再来看看对数组元素或属性的设置操作有哪些。

- 通过索引修改数组元素值:arr[1]=3。
- 修改数组长度:arr.length=0。
- 数组的栈方法:push/pop/shift/unshift。
- 修改原数组的原型方法:splice/fill/sort等。

除了通过数组索引修改数组元素值这种基本操作之外，数组本身还有很多会修改原数组的原型方法。调用这些方法也属于对数组的操作，有些方法的操作语义是"
读取"，而有些方法的操作语义是"设置"。因此，当这些操作发生时，也应该正确地建立响应联系或触发响应。
从上面列出的这些对数组的操作来看，似乎代理数组的难度要比代理普通对象的难度大很多。但事实并非如此，这是因为数组本身也是对象，只不过它是异质对象罢了，它与常规对象的差异并不大。因此，大部分用来代理常规对象的代码对于数组也是生效的。接下来，我们就从通
过索引读取或设置数组的元素值说起

### 数组的索引与length

拿本节开头的例子来说，当通过数组的索引访向元素的值时，已经能够建立响应联系了:

```javascript
const arr = reactive(['foo'])

effect(() => {
    console.log(arr[0])
})

arr[0] = 'bar' // 触发响应
```

但通过索引设置数组的元素值与设置对象的属性值仍然存在根本上的不同，这是因为数组对象部署的内部方法[[DefineOwProperty]]
不同于常规对象。实际上，当我们通过索引设置数组元素的值时，会执行数组对象所部署的内部方法[[Set]]，这一步与设置常规对象的属性值一样。
根据规范可知,内部方法[[set]]其实依赖于[[DefineOwnProperty]]
,到了这里就体现出了差异。数组对象所部署的内部方法[[DefineOwnProperty]]的逻辑定义在规范的10.4.2.1节

![avatar](/Vue/images/第165页-35.png)

步骤描述的内容如下

```text
j.如果index>= oldLen，那么
  I.将oldLenDesc.[[Value]]设置为index +1。
  II.i让 succeeded 的/值 为 OrdinaryDefineOwnProperty(A,"Length",oldLenDesc)。
  III.断言:succeeded 是true。
```

可以看到，规范中明确说明，如果设置的索引值大于数组当前的长度，那么要更新数组length属性。
所以当通过索引设置元素值时，可能会隐式地修改length的属性值。因此在触发
响应时、也应该触发与length属性相关联的副作用函数重新执行，如下面的代码所示:

```javascript
const arr = reactive(['foo']) // 数组的原长度为1

effect(() => {
    console.log(arr.length) // 1
})
// 设置索引1的值会导致数组的长度变为2
arr[1] = 'bar'
```

在这段代码中，数组的原长度为1，并且在副作用函数中访问了length属性。然后设置数组索引为1的元素值，这会导致数组的长度变为2，因此应该触发副作用函数重新执行。
但目前的实现还做不到这一点，为了实现目标，我们需要修改set拦截函数，如下面的代码所示:

```javascript
function createReactive(obj, isShallow = false, isReadanly = false) {
    return new Proxy(obj, {
        set(target, key, newVal, receiver) {
            if (!isReadanly) {
                console.warn(`属性 ${key} 是只读的`)
                return true
            }
            const oldValue = target[key]
            //如果属性不存在，则说明是在添加新的属性，否则是设置已有属性
            //如果代理目标是数组，则检测被设置的索引值是否小于数组长度，//如果是，则视作SET操作，否则是ADD操作
            const type = Array.isArray(target) ? Number(key) < target.length ? 'SET' : 'ADD' : Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
            const res = Reflect.set(target, key, newValue, receiver)
            if (target === receiver.raw) {
                if (oldValue !== newValue && (oldValue === oldValue || newValue === newValue)) {
                    trigger(target, key, type)
                }
            }
            return res
        }
    })
}
```

我们在判断操作类型时，新增了对数组类型的判断。如果代理的目标对象是数组，那么对操作类型的判断会有所区别。
即被设置的索引值如果小于数组长度，就视作SET操作，因为它会改变数组长度;如果设置的索引值大于数组的当前长度，则视作AO0操作，因为这会隐式地变数组的length属性值。
有了这些信息，我们就可以在trigger函数中正确地触发的length属性相关联的副作用函数重新执行了:

```javascript
function trigger(target, key, type) {
    const depsMap = bucket.get(target)
    if (!depsMap) return
    //当操作类型为AOD并且目标对象是数组时，应该取出并执行那些与length 属性相关联的副作用函数
    if (type === 'ADD' && Array.isArray(target)) {
        //取出与length相关联的副作用函数
        const lengthEffects = depsMap.get(length)
        //将这些副作用函数添加到 effectsToRun 中，待执行
        lengthEffects && lengthEffects.forEach(effectFn => {
            if (effectFn !== activeEffect) {
                effectsToRun.add(effectFn)
            }
        })
    }

    effectsToRun.forEach(effectFn => {
        if (effectFn.options.scheduler) {
            effectFn.options.scheduler(effectFn)
        } else {
            effectFn()
        }
    })

}
```

但是反过来思考，其实修改数组的length属性也会隐式地影响数组元素，例如:

```javascript
const arr = reactive(['foo'])

effect(() => {
    // 访问数组的第 0 个元素
    console.log(arr[0]) // foo
})
// 将数组的长度修改为 0，导致第 0 个元素被删除，因此应该触发响应

arr.length = 0
```

如上面的代码所示，在副作用函数内访问了数组的第 0 个元素，
接着将数组的 length 属性修改为 0。我们知道这会隐式地影响数组
元素，即所有元素都被删除，所以应该触发副作用函数重新执行。然
而并非所有对 length 属性的修改都会影响数组中的已有元素，拿上
例来说，如果我们将 length 属性设置为 100，这并不会影响第 0 个
元素，所以也就不需要触发副作用函数重新执行。这让我们意识到，
当修改 length 属性值时，只有那些索引值大于或等于新的 length
属性值的元素才需要触发响应。但无论如何，目前的实现还做不到这
一点，为了实现目标，我们需要修改 set 拦截函数。在调用 trigger
函数触发响应时，应该把新的属性值传递过去：

```javascript
function createReactive(obj, isShallow = false, isReadonly = false) {
    return new Proxy(obj, {
        // 拦截设置操作
        set(target, key, newVal, receiver) {
            if (isReadonly) {
                console.warn(`属性 ${key} 是只读的`)
                return true
            }
            const oldVal = target[key]
            const type = Array.isArray(target) ? Number(key) < target.length ? 'SET' : 'ADD' : Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
            const res = Reflect.set(target, key, newVal, receiver)
            if (target === receiver.raw) {
                if (oldVal !== newVal && (oldVal === oldVal || newVal
                    === newVal)) {
                    // 增加第四个参数，即触发响应的新值
                    trigger(target, key, type, newVal)
                }
            }
            return res
        }
    })
}
```

接着，我们还需要修改 trigger 函数：

```javascript
 // 为 trigger 函数增加第四个参数，newVal，即新值
function trigger(target, key, type, newVal) {
    const depsMap = bucket.get(target)
    if (!depsMap) return
    // 如果操作目标是数组，并且修改了数组的 length 属性
    if (Array.isArray(target) && key === 'length') {
        // 对于索引大于或等于新的 length 值的元素，
        // 需要把所有相关联的副作用函数取出并添加到 effectsToRun 中待执行
        depsMap.forEach((effects, key) => {
            if (key >= newVal) {
                effects.forEach(effectFn => {
                    if (effectFn !== activeEffect) {
                        effectsToRun.add(effectFn)
                    }
                })
            }
        })
    }
    effectsToRun.forEach(effectFn => {
        if (effectFn.options.scheduler) {
            effectFn.options.scheduler(effectFn)
        } else {
            effectFn()
        }
    })
}
```

如上面的代码所示，为 trigger 函数增加了第四个参数，即触发
响应时的新值。在本例中，新值指的是新的 length 属性值，它代表
新的数组长度。接着，我们判断操作的目标是否是数组，如果是，则
需要找到所有索引值大于或等于新的 length 值的元素，然后把与它
们相关联的副作用函数取出并执行。

### 遍历数组

既然数组也是对象，就意味着同样可以使用 for...in 循环遍历：

```javascript
const arr = reactive(['foo'])
effect(() => {
    for (const key in arr) {
        console.log(key) // 0
    }
})
```

这里有必要指出一点，我们应该尽量避免使用 for...in 循环遍
历数组。但既然在语法上是可行的，那么当然也需要考虑。前面我们
提到，数组对象和常规对象的不同仅体现在
[[DefineOwnProperty]] 这个内部方法上，也就是说，使用
for...in 循环遍历数组与遍历常规对象并无差异，因此同样可以使
用 ownKeys 拦截函数进行拦截。下面是我们之前实现的 ownKeys 拦
截函数：

```javascript
function createReactive(obj, isShallow = false, isReadonly = false) {
    return new Proxy(obj, {
        // 省略其他拦截函数
        ownKeys(target) {
            track(target, ITERATE_KEY)
            return Reflect.ownKeys(target)
        }
    })
}
```

这段代码取自前文，当初我们为了追踪对普通对象的 for...in
操作，人为创造了 ITERATE_KEY 作为追踪的 key。但这是为了代理
普通对象而考虑的，对于一个普通对象来说，只有当添加或删除属性
值时才会影响 for...in 循环的结果。所以当添加或删除属性操作发
生时，我们需要取出与 ITERATE_KEY 相关联的副作用函数重新执
行。不过，对于数组来说情况有所不同，我们看看哪些操作会影响
for...in 循环对数组的遍历。

- 添加新元素：arr[100] = 'bar'。
- 修改数组长度：arr.length = 0。

其实，无论是为数组添加新元素，还是直接修改数组的长度，本
质上都是因为修改了数组的 length 属性。一旦数组的 length 属性
被修改，那么 for...in 循环对数组的遍历结果就会改变，所以在这
种情况下我们应该触发响应。很自然的，我们可以在 ownKeys 拦截函
数内，判断当前操作目标 target 是否是数组，如果是，则使用
length作为key去建立响应联系：

```javascript
 function createReactive(obj, isShallow = false, isReadonly = false) {
    return new Proxy(obj, {
        // 省略其他拦截函数
        ownKeys(target) {
            // 如果操作目标 target 是数组，则使用 length 属性作为 key 并建立响应联系
            track(target, Array.isArray(target) ? 'length' : ITERATE_KEY)
            return Reflect.ownKeys(target)
        }
    })
}
```

这样无论是为数组添加新元素，还是直接修改 length 属性，都能够正确地触发响应了：

```javascript
const arr = reactive(['foo'])

effect(() => {
    for (const key in arr) {
        console.log(key)
    }
})

arr[1] = 'bar' // 能够触发副作用函数重新执行
arr.length = 0 // 能够触发副作用函数重新执行
```

讲解了使用 for...in 遍历数组，接下来我们再看看使用
for...of 遍历数组的情况。与 for...in 不同，for...of 是用来
遍历可迭代对象（iterable object）的，因此我们需要先搞清楚什么是
可迭代对象。ES2015 为 JavaScript 定义了迭代协议（iteration
protocol），它不是新的语法，而是一种协议。具体来说，一个对象能
否被迭代，取决于该对象或者该对象的原型是否实现了 @@iterator方法。这里的 @@[name] 标志在 ECMAScript 规范里用来代指
JavaScript 内建的 symbols 值，例如 @@iterator 指的就是
Symbol.iterator 这个值。如果一个对象实现了
Symbol.iterator 方法，那么这个对象就是可以迭代的，例如：

```javascript
 const obj = {
    val: 0,
    [Symbol.iterator]() {
        return {
            next() {
                return {
                    value: obj.val++,
                    done: obj.val > 10 ? true : false
                }
            }
        }
    }
}
```

该对象实现了 Symbol.iterator 方法，因此可以使用for...of 循环遍历它：

```javascript
 for (const value of obj) {
    console.log(value) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
}
```

数组内建了 Symbol.iterator 方法的实现，我们可以做一个实验：

```javascript
const arr = [1, 2, 3, 4, 5]
// 获取并调用数组内建的迭代器方法
const itr = arr[Symbol.iterator]()

console.log(itr.next()) // {value: 1, done: false}
console.log(itr.next()) // {value: 2, done: false}
console.log(itr.next()) // {value: 3, done: false}
console.log(itr.next()) // {value: 4, done: false}
console.log(itr.next()) // {value: 5, done: false}
console.log(itr.next()) // {value: undefined, done: true}
```

可以看到，我们能够通过将 Symbol.iterator 作为键，获取数
组内建的迭代器方法。然后手动执行迭代器的 next 函数，这样也可
以得到期望的结果。这也是默认情况下数组可以使用 for...of 遍历
的原因：

```javascript
const arr = [1, 2, 3, 4, 5]

for (const val of arr) {
    console.log(val) // 1, 2, 3, 4, 5
}
```

实际上，想要实现对数组进行 for...of 遍历操作的拦截，关键
点在于找到 for...of 操作依赖的基本语义。在规范的 23.1.5.1 节中。

![avatar](/Vue/images/第173页-36.png)

图中第 3 步的 b 子步骤所描述的内容如下。

```text
b. 重复以下步骤。
    i. 如果 array 有 [[TypedArrayName]] 内部槽，那么
        1. 如果 IsDetachedBuffer(array.[[ViewedArrayBuffer]]) 是 true，则抛出 TypeError 异常。
        2. 让 len 的值为 array.[[ArrayLength]]。
    ii. 否则
        1. 让 len 的值为 LengthOfArrayLike(array)。
    iii. 如果 index >= len，则返回 undefined。
    iv. 如果 kind 是 key，则执行 ? Yield(𝔽(index))。
    v. 否则
        1. 让 elementKey 的值为 ! ToString(𝔽(index))。
        2. 让 elementValue 的值为 ? Get(array,elementKey)。
        3. 如果 kind 是 value，执行 ?Yield(elementValue)。
        4. 否则
            a. 断言：kind 是 key + value。
            b. 执行：? Yield(! CreateArrayFromList(«𝔽(index), elementValue »))。
    vi. 将 index 设置为 index + 1。
```

可以看到，数组迭代器的执行会读取数组的 length 属性。如果迭代的是数组元素值，还会读取数组的索引。其实我们可以给出一个数组迭代器的模拟实现：

```javascript
const arr = [1, 2, 3, 4, 5]
arr[Symbol.iterator] = function () {
    const target = this
    const len = target.length
    let index = 0
    return {
        next() {
            return {
                value: index < len ? target[index] : undefined,
                done: index++ >= len
            }
        }
    }
}
```

如上面的代码所示，我们用自定义的实现覆盖了数组内建的迭代器方法，但它仍然能够正常工作。

这个例子表明，迭代数组时，只需要在副作用函数与数组的长度和索引之间建立响应联系，就能够实现响应式的 for...of 迭代：

```javascript
const arr = reactive([1, 2, 3, 4, 5])

effect(() => {
    for (const val of arr) {
        console.log(val)
    }
})

arr[1] = 'bar' // 能够触发响应
arr.length = 0 // 能够触发响应
```

可以看到，不需要增加任何代码就能够使其正确地工作。这是因为只要数组的长度和元素值发生改变，副作用函数自然会重新执行。
这里不得不提的一点是，数组的 values 方法的返回值实际上就是数组内建的迭代器，我们可以验证这一点：

```javascript
 console.log(Array.prototype.values === Array.prototype[Symbol.iterator]) // true
```

换句话说，在不增加任何代码的情况下，我们也能够让数组的迭代器方法正确地工作：

```javascript
 const arr = reactive([1, 2, 3, 4, 5])

effect(() => {
    for (const val of arr.values()) {
        console.log(val)
    }
})

arr[1] = 'bar' // 能够触发响应
arr.length = 0 // 能够触发响应
```

最后需要指出的是，无论是使用 for...of 循环，还是调用
values 等方法，它们都会读取数组的 Symbol.iterator 属性。该
属性是一个 symbol 值，为了避免发生意外的错误，以及性能上的考
虑，我们不应该在副作用函数与 Symbol.iterator 这类 symbol 值
之间建立响应联系，因此需要修改 get 拦截函数，如以下代码所示：

```javascript
 function createReactive(obj, isShallow = false, isReadonly = false) {
    return new Proxy(obj, {
        // 拦截读取操作
        get(target, key, receiver) {
            console.log('get: ', key)
            if (key === 'raw') {
                return target
            }

            // 添加判断，如果 key 的类型是 symbol，则不进行追踪
            if (!isReadonly && typeof key !== 'symbol') {
                track(target, key)
            }

            const res = Reflect.get(target, key, receiver)

            if (isShallow) {
                return res
            }

            if (typeof res === 'object' && res !== null) {
                return isReadonly ? readonly(res) : reactive(res)
            }

            return res
        },
    })
}
```

在调用 track 函数进行追踪之前，需要添加一个判断条件，即只有当 key 的类型不是 symbol 时才进行追踪，这样就避免了上述问题。

### 数组的查找方法

通过上一节的介绍我们意识到，数组的方法内部其实都依赖了对象的基本语义。所以大多数情况下，我们不需要做特殊处理即可让这些方法按预期工作，例如：

```javascript
const arr = reactive([1, 2])

effect(() => {
    console.log(arr.includes(1)) // 初始打印 true
})

arr[0] = 3 // 副作用函数重新执行，并打印 false
```

这是因为 includes 方法为了找到给定的值，它内部会访问数组的 length 属性以及数组的索引，因此当我们修改某个索引指向的元素值后能够触发响应。
然而 includes 方法并不总是按照预期工作，举个例子：

```javascript
const obj = {}
const arr = reactive([obj])

console.log(arr.includes(arr[0])) // false
```

如上面的代码所示。我们首先定义一个对象 obj，并将其作为数组的第一个元素，然后调用 reactive 函数为其创建一个响应式对
象，接着尝试调用 includes 方法在数组中进行查找，看看其中是否包含第一个元素。很显然，这个操作应该返回 true，但如果你尝试运
行这段代码，会发现它返回了 false。
为什么会这样呢？这需要我们去查阅语言规范，看看 includes方法的执行流程是怎样的。规范的 23.1.3.13 节给出了 includes 方法的执行流程。

![avatar](/Vue/images/第178页-37.png)

```text
01. 让 O 的值为 ? ToObject(this value)。
第 10 步所描述的内容如下。
10. 重复，while 循环（条件 k < len），
    a. 让 elementK 的值为 ? Get(O, ! ToString(𝔽(k)))
    的结果。
    b. 如果 SameValueZero(searchElement, elementK)
    是 true，则返回 true。
    c. 将 k 设置为 k + 1。
```

这里我们注意第 1 步，让 O 的值为 ? ToObject(this
value)，这里的 this 是谁呢？在 arr.includes(arr[0]) 语句
中，arr 是代理对象，所以 includes 函数执行时的 this 指向的是
代理对象，即 arr。接着我们看第 10.a 步，可以看到 includes 方法
会通过索引读取数组元素的值，但是这里的 O 是代理对象 arr。我们
知道，通过代理对象来访问元素值时，如果值仍然是可以被代理的，
那么得到的值就是新的代理对象而非原始对象。下面这段 get 拦截函
数内的代码可以证明这一点：

```javascript
if (typeof res === 'object' && res !== null) {
    // 如果值可以被代理，则返回代理对象
    return isReadonly ? readonly(res) : reactive(res)
}
```

知道这些后，我们再回头看这句代码：
arr.includes(arr[0])。其中，arr[0] 得到的是一个代理对象，
而在 includes 方法内部也会通过 arr 访问数组元素，从而也得到一
个代理对象，问题是这两个代理对象是不同的。这是因为每次调用
reactive 函数时都会创建一个新的代理对象：

```javascript
function reactive(obj) {
    // 每次调用 reactive 时，都会创建新的代理对象
    return createReactive(obj)
}
```

即使参数 obj 是相同的，每次调用 reactive 函数时，也都会创建新的代理对象。这个问题的解决方案如下所示：

```javascript
 // 定义一个 Map 实例，存储原始对象到代理对象的映射

const reactiveMap = new Map()

function reactive(obj) {
    // 优先通过原始对象 obj 寻找之前创建的代理对象，如果找到了，直接返回已有的代理对象

    const existionProxy = reactiveMap.get(obj)

    if (existionProxy) return existionProxy


    // 否则，创建新的代理对象

    const proxy = createReactive(obj)
    // 存储到 Map 中，从而避免重复创建

    reactiveMap.set(obj, proxy)


    return proxy

}
```

在上面这段代码中，我们定义了 reactiveMap，用来存储原始对
象到代理对象的映射。每次调用 reactive 函数创建代理对象之前，
优先检查是否已经存在相应的代理对象，如果存在，则直接返回已有
的代理对象，这样就避免了为同一个原始对象多次创建代理对象的问
题。接下来，我们再次运行本节开头的例子：

```javascript
const obj = {}
const arr = reactive([obj])

console.log(arr.includes(arr[0])) // true
```

可以发现，此时的行为已经符合预期了。然而，还不能高兴得太早，再来看下面的代码：

```javascript
const obj = {}
const arr = reactive([obj])

console.log(arr.includes(obj)) // false
```

在上面这段代码中，我们直接把原始对象作为参数传递给
includes 方法，这是很符合直觉的行为。而从用户的角度来看，自
己明明把 obj 作为数组的第一个元素了，为什么在数组中却仍然找不
到 obj 对象呢？其实原因很简单，因为 includes 内部的 this 指向
的是代理对象 arr，并且在获取数组元素时得到的值也是代理对象，
所以拿原始对象 obj 去查找肯定找不到，因此返回 false。为此，我
们需要重写数组的 includes 方法并实现自定义的行为，才能解决这个问题。
首先，我们来看如何重写 includes 方法，如下面的代码所示：

```javascript
 const arrayInstrumentations = {
    includes: function () {/* ... */
    }
}

function createReactive(obj, isShallow = false, isReadonly = false) {
    return new Proxy(obj, {
        // 拦截读取操作
        get(target, key, receiver) {
            console.log('get: ', key)
            if (key === 'raw') {
                return target
            }
            // 如果操作的目标对象是数组，并且 key 存在于arrayInstrumentations 上，
            // 那么返回定义在 arrayInstrumentations 上的值
            if (Array.isArray(target) && arrayInstrumentations.hasOwnProperty(key)) {
                return Reflect.get(arrayInstrumentations, key, receiver)
            }

            if (!isReadonly && typeof key !== 'symbol') {
                track(target, key)
            }

            const res = Reflect.get(target, key, receiver)
            if (isShallow) {
                return res
            }

            if (typeof res === 'object' && res !== null) {
                return isReadonly ? readonly(res) : reactive(res)
            }

            return res
        }
    })
}
```

在上面这段代码中，我们修改了 get 拦截函数，目的是重写数组的 includes 方法。具体怎么做呢？我们知道，arr.includes 可以
理解为读取代理对象 arr 的 includes 属性，这就会触发 get 拦截函数，在该函数内检查 target 是否是数组，如果是数组并且读取的
键值存在于 arrayInstrumentations 上，则返回定义在arrayInstrumentations 对象上相应的值。
也就是说，当执行arr.includes 时，实际执行的是定义在 arrayInstrumentations 上的 includes 函数，这样就实现了重写。

接下来，我们就可以自定义 includes 函数了：

```javascript
const originMethod = Array.prototype.includes
const arrayInstrumentations = {
    includes: function (...args) {
        // this 是代理对象，先在代理对象中查找，将结果存储到 res 中
        let res = originMethod.apply(this, args)

        if (res === false) {
            // res 为 false 说明没找到，通过 this.raw 拿到原始数组，再去其中查找并更新 res 值
            res = originMethod.apply(this.raw, args)
        }
        // 返回最终结果
        return res
    }
}
```

如上面这段代码所示，其中 includes 方法内的 this 指向的是代理对象，我们先在代理对象中进行查找，这其实是实现了arr.include(obj) 的默认行为。
如果找不到，通过 this.raw 拿到原始数组，再去其中查找，最后返回结果，这样就解决了上述问题。运行如下测试代码：

```javascript
const obj = {}
const arr = reactive([obj])

console.log(arr.includes(obj)) // true
```

可以发现，现在代码的行为已经符合预期了。除了 includes 方法之外，还需要做类似处理的数组方法有indexOf 和 lastIndexOf，因为它们都属于根据给定的值返回查找结果的方法。完整的代码如下：

```javascript
const arrayInstrumentations = {}

;['includes', 'indexOf', 'lastIndexOf'].forEach(method => {
    const originMethod = Array.prototype[method]
    arrayInstrumentations[method] = function (...args) {
        // this 是代理对象，先在代理对象中查找，将结果存储到 res 中
        let res = originMethod.apply(this, args)

        if (res === false || res === -1) {
            // res 为 false 说明没找到，通过 this.raw 拿到原始数组，再去其中查找，并更新 res 值
            res = originMethod.apply(this.raw, args)
        }
        // 返回最终结果
        return res
    }
})
```

### 隐式修改数组长度的原型方法

本节中我们讲解如何处理那些会隐式修改数组长度的方法，主要指的是数组的栈方法，例如 push/pop/shift/unshift。
除此之外，splice 方法也会隐式地修改数组长度，我们可以查阅规范来证实这一点。
以 push 方法为例，规范的 23.1.3.20 节定义了 push 方法的执行流程。

![avatar](/Vue/images/第183页-38.png)

```text
当调用 push 方法并传递 0 个或多个参数时，会执行以下步骤。
1. 让 O 的值为 ? ToObject(this value)。
2. 让 len 的值为 ? LengthOfArrayLike(O)。
3. 让 argCount 的值为 items 的元素数量。
4. 如果 len + argCount > 253 - 1，则抛出 TypeError 异常。
5. 对于 items 中的每一个元素 E：
    a. 执行 ? Set(O, ! ToString( (len)), E, true)；
    b. 将 len 设置为 len + 1。
6. 执行 ? Set(O, ''length'', (len), true)。
7. 返回 (len)。
```

由第 2 步和第 6 步可知，当调用数组的 push 方法向数组中添加元素时，既会读取数组的 length 属性值，也会设置数组的 length属性值。
这会导致两个独立的副作用函数互相影响。以下面的代码为例：

```javascript
const arr = reactive([])
// 第一个副作用函数
effect(() => {
    arr.push(1)
})

// 第二个副作用函数
effect(() => {
    arr.push(1)
})
```

如果你尝试在浏览器中运行上面这段代码，会得到栈溢出的错误
（Maximum call stack size exceeded）。
为什么会这样呢？我们来详细分析上面这段代码的执行过程。

- 第一个副作用函数执行。在该函数内，调用 arr.push 方法向数
组中添加了一个元素。我们知道，调用数组的 push 方法会间接
读取数组的 length 属性。所以，当第一个副作用函数执行完毕
后，会与 length 属性建立响应联系。
- 接着，第二个副作用函数执行。同样，它也会与 length 属性建
立响应联系。但不要忘记，调用 arr.push 方法不仅会间接读取
数组的 length 属性，还会间接设置 length 属性的值。
- 第二个函数内的 arr.push 方法的调用设置了数组的 length 属
性值。于是，响应系统尝试把与 length 属性相关联的副作用函
数全部取出并执行，其中就包括第一个副作用函数。问题就出在
这里，可以发现，第二个副作用函数还未执行完毕，就要再次执
行第一个副作用函数了。
- 第一个副作用函数再次执行。同样，这会间接设置数组的 length
属性。于是，响应系统又要尝试把所有与 length 属性相关联的
副作用函数取出并执行，其中就包含第二个副作用函数。
- 如此循环往复，最终导致调用栈溢出。

问题的原因是 push 方法的调用会间接读取 length 属性。所
以，只要我们“屏蔽”对 length 属性的读取，从而避免在它与副作用
函数之间建立响应联系，问题就迎刃而解了。这个思路是正确的，因
为数组的 push 方法在语义上是修改操作，而非读取操作，所以避免
建立响应联系并不会产生其他副作用。有了解决思路后，我们尝试实
现它，这需要重写数组的 push 方法，如下面的代码所示：

```javascript
// 一个标记变量，代表是否进行追踪。默认值为 true，即允许追踪
let shouldTrack = true
// 重写数组的 push 方法
;['push'].forEach(method => {
    // 取得原始 push 方法
    const originMethod = Array.prototype[method]
    // 重写
    arrayInstrumentations[method] = function (...args) {
        // 在调用原始方法之前，禁止追踪
        shouldTrack = false
        // push 方法的默认行为
        let res = originMethod.apply(this, args)
        // 在调用原始方法之后，恢复原来的行为，即允许追踪
        shouldTrack = true
        return res
    }
})
```

在这段代码中，我们定义了一个标记变量 shouldTrack，它是一
个布尔值，代表是否允许追踪。接着，我们重写了数组的 push 方
法，利用了前文介绍的 arrayInstrumentations 对象。重写后的
push 方法保留了默认行为，只不过在执行默认行为之前，先将标记变
量 shouldTrack 的值设置为 false，即禁止追踪。当 push 方法的
默认行为执行完毕后，再将标记变量 shouldTrack 的值还原为
true，代表允许追踪。最后，我们还需要修改 track 函数，如下面
的代码所示：

```javascript
function track(target, key) {
    // 当禁止追踪时，直接返回
    if (!activeEffect || !shouldTrack) return
    // 省略部分代码
}
```

可以看到，当标记变量 shouldTrack 的值为 false 时，即禁止追踪时，track 函数会直接返回。这样，当 push 方法间接读取length 属性值时，由于此时是禁止追踪的状态，所以 length 属性与副作用函数之间不会建立响应联系。
这样就实现了前文给出的方案。我们再次尝试运行下面这段测试代码：

```javascript
const arr = reactive([])
// 第一个副作用函数
effect(() => {
    arr.push(1)
})

// 第二个副作用函数
effect(() => {
    arr.push(1)
})
```

会发现它能够正确地工作，并且不会导致调用栈溢出。除了 push 方法之外，pop、shift、unshift 以及 splice 等方法都需要做类似的处理。完整的代码如下：

```javascript
let shouldTrack = true
    // 重写数组的 push、pop、shift、unshift 以及 splice 方法
;['push', 'pop', 'shift', 'unshift', 'splice'].forEach(method => {
    const originMethod = Array.prototype[method]
    arrayInstrumentations[method] = function (...args) {
        shouldTrack = false
        let res = originMethod.apply(this, args)
        shouldTrack = true
        return res
    }
})
```

## 代理 Set 和 Map

从本节开始，我们将介绍集合类型数据的响应式方案。集合类型
包括 Map/Set 以及 WeakMap/WeakSet。使用 Proxy 代理集合类型的
数据不同于代理普通对象，因为集合类型数据的操作与普通对象存在
很大的不同。下面总结了 Set 和 Map 这两个数据类型的原型属性和方
法。

Set 类型的原型属性和方法如下。
- `size`：返回集合中元素的数量。
- `add(value)`：向集合中添加给定的值。
- `clear()`：清空集合。
- `delete(value)`：从集合中删除给定的值。
- `has(value)`：判断集合中是否存在给定的值。
- `keys()`：返回一个迭代器对象。可用于 for...of 循环，迭代器对象产生的值为集合中的元素值。
- `values()`：对于 Set 集合类型来说，keys() 与 values() 等价。
- `entries()`：返回一个迭代器对象。迭代过程中为集合中的每一个元素产生一个数组值 [value, value]。
- `forEach(callback[, thisArg])`：forEach 函数会遍历集合中的所有元素，并对每一个元素调用 callback 函数。forEach 函数接收可选的第二个参数 thisArg，用于指定callback 函数执行时的 this 值。

Map 类型的原型属性和方法如下。
- `size`：返回 Map 数据中的键值对数量。
- `clear()`：清空 Map。
- `delete(key)`：删除指定 key 的键值对。
- `has(key)`：判断 Map 中是否存在指定 key 的键值对。
- `get(key)`：读取指定 key 对应的值。
- `set(key, value)`：为 Map 设置新的键值对。
- `keys()`：返回一个迭代器对象。迭代过程中会产生键值对的key值。
- `values()`：返回一个迭代器对象。迭代过程中会产生键值对的value 值。
- `entries()`：返回一个迭代器对象。迭代过程中会产生由 [key,value] 组成的数组值。
- `forEach(callback[, thisArg])`：forEach 函数会遍历Map 数据的所有键值对，并对每一个键值对调用 callback 函数。forEach 函数接收可选的第二个参数 thisArg，用于指定callback 函数执行时的 this 值。

观察上述列表可以发现，Map 和 Set 这两个数据类型的操作方法
相似。它们之间最大的不同体现在，Set 类型使用 add(value) 方法
添加元素，而 Map 类型使用 set(key, value) 方法设置键值对，并
且 Map 类型可以使用 get(key) 方法读取相应的值。既然两者如此相
似，那么是不是意味着我们可以用相同的处理办法来实现对它们的代
理呢？没错，接下来，我们就深入探讨如何实现对 Set 和 Map 类型数
据的代理。

### 如何代理 Set 和 Map

前文讲到，Set 和 Map 类型的数据有特定的属性和方法用来操作自身。这一点与普通对象不同，如下面的代码所示：

```javascript
// 普通对象的读取和设置操作
const obj = {foo: 1}
obj.foo // 读取属性
obj.foo = 2 // 设置属性

// 用 get/set 方法操作 Map 数据
const map = new Map()
map.set('key', 1) // 设置数据
map.get('key') // 读取数据
```

正是因为这些差异的存在，我们不能像代理普通对象那样代理Set 和 Map 类型的数据。但整体思路不变，即当读取操作发生时，应该调用 track 函数建立响应联系；当设置操作发生时，应该调用trigger 函数触发响应，例如：

```javascript
const proxy = reactive(new Map([['key', 1]]))

effect(() => {
    console.log(proxy.get('key')) // 读取键为 key 的值
})

proxy.set('key', 2) // 修改键为 key 的值，应该触发响应
```

当然，这段代码展示的效果是我们最终要实现的目标。但在动手实现之前，我们有必要先了解关于使用 Proxy 代理 Set 或 Map 类型数据的注意事项。

```javascript
const s = new Set([1, 2, 3])
const p = new Proxy(s, {})
console.log(p.size) // 报错 TypeError: Method get Set.prototype.size called on incompatible receiver
```

在这段代码中，我们首先定义了一个 Set 类型的数据 s，接着为它创建一个代理对象 p。
由于代理的目标对象是 Set 类型，因此我们可以通过读取它的 p.size 属性获取元素的数量。但不幸的是，我们得到了一个错误。
错误信息的大意是“在不兼容的 receiver 上调用了get Set.prototype.size 方法”。
由此我们大概能猜到，size 属性应该是一个访问器属性，所以它作为方法被调用了,通过查阅规范可以证实这一点。

![avatar](/Vue/images/第190页-40.png)

```text
Set.prototype.size 是一个访问器属性，它的 set 访问器函数是 undefined，它的 get 访问器函数会执行以下步骤。
    1. 让 S 的值为 this。
    2. 执行 ? RequireInternalSlot(S, [[SetData]])。
    3. 让 entries 的值为 List，即 S.[[SetData]]。
    4. 让 count 的 值为 0。
    5. 对于 entries 中 的每个元素 e，执行：
    a. 如果 e 不是空的，则将 count 设置为 count + 1。
    6. 返回 (count)。
```

由此可知，Set.prototype.size 是一个访问器属性。这里的关键点在第 1 步和第 2 步。根据第 1 步的描述：让 S 的值为 this。
这 里的 this 是谁呢？由于我们是通过代理对象 p 来访问 size 属性的，所以 this 就是代理对象 p。接着在第 2 步中，调用抽象方法RequireInternalSlot(S, [[SetData]]) 来检查 S 是否存在内部槽 [[SetData]]。
很显然，代理对象 S 不存在 [[SetData]] 这个内部槽，于是会抛出一个错误，也就是前面例子中得到的错误。

为了修复这个问题，我们需要修正访问器属性的 getter 函数执行时的 this 指向，如下面的代码所示：

```javascript
const s = new Set([1, 2, 3])
const p = new Proxy(s, {
    get(target, key, receiver) {
        if (key === 'size') {
            // 如果读取的是 size 属性
            // 通过指定第三个参数 receiver 为原始对象 target 从而修复问题
            return Reflect.get(target, key, target)
        }
        // 读取其他属性的默认行为
        return Reflect.get(target, key, receiver)
    }
})

console.log(s.size) // 3
```

在上面这段代码中，我们在创建代理对象时增加了 get 拦截函
数。然后检查读取的属性名称是不是 size，如果是，则在调用
Reflect.get 函数时指定第三个参数为原始 Set 对象，这样访问器
属性 size 的 getter 函数在执行时，其 this 指向的就是原始 Set
对象而非代理对象了。由于原始 Set 对象上存在 [[SetData]] 内部
槽，因此程序得以正确运行。

接着，我们再来尝试从 Set 中删除数据，如下面的代码所示：

```javascript
const s = new Set([1, 2, 3])
const p = new Proxy(s, {
    get(target, key, receiver) {
        if (key === 'size') {
            return Reflect.get(target, key, target)
        }
        // 读取其他属性的默认行为
        return Reflect.get(target, key, receiver)
    }
})
// 调用 delete 方法删除值为 1 的元素
// 会得到错误 TypeError: Method Set.prototype.delete called on incompatible receiver [object Object]
p.delete(1)
```

可以看到，调用 p.delete 方法时会得到一个错误，这个错误与
前文讲解的访问 p.size 属性时发生的错误非常相似。为了搞清楚问
题的原因，我们需要详细分析当调用 p.delete(1) 方法时都发生了
什么。

实际上，访问 p.size 与访问 p.delete 是不同的。这是因为
size 是属性，是一个访问器属性，而 delete 是一个方法。当访问
p.size 时，访问器属性的 getter 函数会立即执行，此时我们可以
通过修改 receiver 来改变 getter 函数的 this 的指向。而当访问
p.delete 时，delete 方法并没有执行，真正使其执行的语句是
p.delete(1) 这句函数调用。因此，无论怎么修改 receiver，
delete 方法执行时的 this 都会指向代理对象 p，而不会指向原始
Set 对象。想要修复这个问题也不难，只需要把 delete 方法与原始
数据对象绑定即可，如以下代码所示：

```javascript
const s = new Set([1, 2, 3])
const p = new Proxy(s, {
    get(target, key, receiver) {
        if (key === 'size') {
            return Reflect.get(target, key, target)
            }
            // 将方法与原始数据对象 target 绑定后返回
            return target[key].bind(target)
    }
})
// 调用 delete 方法删除值为 1 的元素，正确执行
p.delete(1)
```

在上面这段代码中，我们使用 target[key].bind(target)代替了 Reflect.get(target, key, receiver)。
可以看到，我们使用 bind 函数将用于操作数据的方法与原始数据对象 target 做了绑定。
这样当 p.delete(1) 语句执行时，delete 函数的 this 总是指向原始数据对象而非代理对象，于是代码能够正确执行。

最后，为了后续讲解方便以及代码的可扩展性，我们将 new Proxy 也封装到前文介绍的 createReactive 函数中：

```javascript
const reactiveMap = new Map()
// reactive 函数与之前相比没有变化
function reactive(obj) {
    const existionProxy = reactiveMap.get(obj)
    if (existionProxy) return existionProxy
    const proxy = createReactive(obj)
    reactiveMap.set(obj, proxy)
    return proxy
}

// 在 createReactive 里封装用于代理 Set/Map 类型数据的逻辑
function createReactive(obj, isShallow = false, isReadonly = false) {
    return new Proxy(obj, {
    get(target, key, receiver) {
        if (key === 'size') {
        return Reflect.get(target, key, target)
        }

        return target[key].bind(target)
        }
    })
}
```

这样，我们就可以很简单地创建代理数据了：

```javascript
const p = reactive(new Set([1, 2, 3]))
console.log(p.size) // 3
```

### 建立响应联系

了解了为 Set 和 Map 类型数据创建代理时的注意事项之后，我们就可以着手实现 Set 类型数据的响应式方案了。
其实思路并不复杂，以下面的代码为例：

```javascript
const p = reactive(new Set([1, 2, 3]))

effect(() => {
  // 在副作用函数内访问 size 属性
  console.log(p.size)
})
// 添加值为 1 的元素，应该触发响应
p.add(1)
```

这段代码展示了响应式 Set 类型数据的工作方式。首先，在副作
用函数内访问了 p.size 属性；接着，调用 p.add 函数向集合中添加
数据。由于这个行为会间接改变集合的 size 属性值，所以我们期望
副作用函数会重新执行。为了实现这个目标，我们需要在访问 size
属性时调用 track 函数进行依赖追踪，然后在 add 方法执行时调用
trigger 函数触发响应。下面的代码展示了如何进行依赖追踪：

```javascript
function createReactive(obj, isShallow = false, isReadonly = false) {
    return new Proxy(obj, {
        get(target, key, receiver) {
            if (key === 'size') {
                // 调用 track 函数建立响应联系
                track(target, ITERATE_KEY)
                return Reflect.get(target, key, target)
            }

            return target[key].bind(target)
        }
    })
}
```

可以看到，当读取 size 属性时，只需要调用 track 函数建立响
应联系即可。这里需要注意的是，响应联系需要建立在 ITERATE_KEY
与副作用函数之间，这是因为任何新增、删除操作都会影响 size 属
性。接着，我们来看如何触发响应。当调用 add 方法向集合中添加新
元素时，应该怎么触发响应呢？很显然，这需要我们实现一个自定义
的 add 方法才行，如以下代码所示：

```javascript
 // 定义一个对象，将自定义的 add 方法定义到该对象下
 const mutableInstrumentations = {
     add(key) {/* ... */}
 }

 function createReactive(obj, isShallow = false, isReadonly = false) {
    return new Proxy(obj, {
        get(target, key, receiver) {
        // 如果读取的是 raw 属性，则返回原始数据对象 target
        if (key === 'raw') return target
        if (key === 'size') {
        track(target, ITERATE_KEY)
        return Reflect.get(target, key, target)
        }
        // 返回定义在 mutableInstrumentations 对象下的方法
        return mutableInstrumentations[key]
        }
    })
}
```

首先，定义一个对象 mutableInstrumentations，我们会将
所有自定义实现的方法都定义到该对象下，例如
mutableInstrumentations.add 方法。然后，在 get 拦截函数内
返回定义在 mutableInstrumentations 对象中的方法。这样，当
通过 p.add 获取方法时，得到的就是我们自定义的
mutableInstrumentations.add 方法了。有了自定义实现的方法
后，就可以在其中调用 trigger 函数触发响应了：

```javascript
 // 定义一个对象，将自定义的 add 方法定义到该对象下
 const mutableInstrumentations = {
    add(key) {
        // this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象
        const target = this.raw
        // 通过原始数据对象执行 add 方法添加具体的值，
        // 注意，这里不再需要 .bind 了，因为是直接通过 target 调用并执行的
        const res = target.add(key)
        // 调用 trigger 函数触发响应，并指定操作类型为 ADD
        trigger(target, key, 'ADD')
        // 返回操作结果
        return res
    }
 }
```

如上面的代码所示，自定义的 add 函数内的 this 仍然指向代理
对象，所以需要通过 this.raw 获取原始数据对象。有了原始数据对
象后，就可以通过它调用 target.add 方法，这样就不再需要 .bind
绑定了。待添加操作完成后，调用 trigger 函数触发响应。需要注意
的是，我们指定了操作类型为 ADD，这一点很重要。还记得 trigger
函数的实现吗？我们来回顾一下，如下面的代码片段所示：

```javascript
 function trigger(target, key, type, newVal) {
 const depsMap = bucket.get(target)
 if (!depsMap) return
 const effects = depsMap.get(key)
 // 当操作类型 type 为 ADD 时，会取出与 ITERATE_KEY 相关联的副作用函数并执行
 if (type === 'ADD' || type === 'DELETE') {
    const iterateEffects = depsMap.get(ITERATE_KEY)
    iterateEffects && iterateEffects.forEach(effectFn => {
    if (effectFn !== activeEffect) {
    effectsToRun.add(effectFn)
    }
    })
 }

 effectsToRun.forEach(effectFn => {
    if (effectFn.options.scheduler) {
    effectFn.options.scheduler(effectFn)
    } else {
    effectFn()
    }
 })
 }
```

当操作类型是 ADD 或 DELETE 时，会取出与 ITERATE_KEY 相关联的副作用函数并执行，这样就可以触发通过访问 size 属性所收集的副作用函数来执行了。

当然，如果调用 add 方法添加的元素已经存在于 Set 集合中了，就不再需要触发响应了，这样做对性能更加友好，因此，我们可以对代码做如下优化：

```javascript
 const mutableInstrumentations = {
    add(key) {
        const target = this.raw
        // 先判断值是否已经存在
        const hadKey = target.has(key)
        // 只有在值不存在的情况下，才需要触发响应
        const res = target.add(key)
        if (!hadKey) {
            trigger(target, key, 'ADD')
        }
        return res
    }
}
```

在上面这段代码中，我们先调用 target.has 方法判断值是否已经存在，只有在值不存在的情况下才需要触发响应。

在此基础上，我们可以按照类似的思路轻松地实现 delete 方法：

```javascript
 const mutableInstrumentations = {
    delete(key) {
    const target = this.raw
    const hadKey = target.has(key)
    const res = target.delete(key)
    // 当要删除的元素确实存在时，才触发响应
    if (hadKey) {
        trigger(target, key, 'DELETE')
    }
    return res
    }
}
```

如上面的代码所示，与 add 方法的区别在于，delete 方法只有在要删除的元素确实在集合中存在时，才需要触发响应，这一点恰好与 add 方法相反。

### 避免污染原始数据

本节中我们借助 Map 类型数据的 set 和 get 这两个方法来讲解什么是“避免污染原始数据”及其原因。

Map 数据类型拥有 get 和 set 这两个方法，当调用 get 方法读取数据时，需要调用 track 函数追踪依赖建立响应联系；当调用 set方法设置数据时，需要调用 trigger 方法触发响应。如下面的代码所示:

```javascript
 const p = reactive(new Map([['key', 1]]))

 effect(() => {
 console.log(p.get('key'))
 })

 p.set('key', 2) // 触发响应
```

其实想要实现上面这段代码所展示的功能并不难，因为我们已经有了实现 add、delete 等方法的经验。下面是 get 方法的具体实现：

```javascript
const mutableInstrumentations = {
    get(key) {
        // 获取原始对象
        const target = this.raw
        // 判断读取的 key 是否存在
        const had = target.has(key)
        // 追踪依赖，建立响应联系
        track(target, key)
        // 如果存在，则返回结果。这里要注意的是，如果得到的结果 res 仍然是可代理的数据，
        // 则要返回使用 reactive 包装后的响应式数据
        if (had) {
            const res = target.get(key)
            return typeof res === 'object' ? reactive(res) : res
        }
    }
}
```

如上面的代码及注释所示，整体思路非常清晰。这里有一点需要
注意，在非浅响应的情况下，如果得到的数据仍然可以被代理，那么
要调用 reactive(res) 将数据转换成响应式数据后返回。在浅响应
模式下，就不需要这一步了。由于前文讲解过如何实现浅响应，因此
这里不再详细讨论。

接着，我们来讨论 set 方法的实现。简单来说，当 set 方法被调用时，需要调用 trigger 方法触发响应。只不过在触发响应的时候，需要区分操作的类型是 SET 还是 ADD，如下面的代码所示：

```javascript
const mutableInstrumentations = {
set(key, value) {
const target = this.raw
const had = target.has(key)
// 获取旧值
const oldValue = target.get(key)
// 设置新值
target.set(key, value)
// 如果不存在，则说明是 ADD 类型的操作，意味着新增
if (!had) {
trigger(target, key, 'ADD')
} else if (oldValue !== value || (oldValue === oldValue &&
value === value)) {
// 如果不存在，并且值变了，则是 SET 类型的操作，意味着修改
trigger(target, key, 'SET')
}
}
}
```

这段代码的关键点在于，我们需要判断设置的 key 是否存在，以
便区分不同的操作类型。我们知道，对于 SET 类型和 ADD 类型的操作
来说，它们最终触发的副作用函数是不同的。因为 ADD 类型的操作会
对数据的 size 属性产生影响，所以任何依赖 size 属性的副作用函数
都需要在 ADD 类型的操作发生时重新执行。

上面给出的 set 函数的实现能够正常工作，但它仍然存在问题，即 set 方法会污染原始数据。这是什么意思呢？来看下面的代码：

```javascript
// 原始 Map 对象 m
const m = new Map()
// p1 是 m 的代理对象
const p1 = reactive(m)
// p2 是另外一个代理对象
const p2 = reactive(new Map())
// 为 p1 设置一个键值对，值是代理对象 p2
p1.set('p2', p2)

effect(() => {
// 注意，这里我们通过原始数据 m 访问 p2
console.log(m.get('p2').size)
})
// 注意，这里我们通过原始数据 m 为 p2 设置一个键值对 foo --> 1
m.get('p2').set('foo', 1)
```

在这段代码中，我们首先创建了一个原始 Map 对象 m，p1 是对象
m 的代理对象，接着创建另外一个代理对象 p2，并将其作为值设置给
p1，即 p1.set('p2', p2)。接下来问题出现了，在副作用函数
中，我们通过原始数据 m 来读取数据值，然后又通过原始数据 m 设置
数据值，此时发现副作用函数重新执行了。这其实不是我们所期望的
行为，因为原始数据不应该具有响应式数据的能力，否则就意味着用
户既可以操作原始数据，又能够操作响应式数据，这样一来代码就乱
套了。

那么，导致问题的原因是什么呢？其实很简单，观察我们前面实现的 set 方法：

```javascript
const mutableInstrumentations = {
set(key, value) {
const target = this.raw
const had = target.has(key)
const oldValue = target.get(key)
// 我们把 value 原封不动地设置到原始数据上
target.set(key, value)
if (!had) {
trigger(target, key, 'ADD')
} else if (oldValue !== value || (oldValue === oldValue &&
value === value)) {
trigger(target, key, 'SET')
}
}
}
```

在 set 方法内，我们把 value 原样设置到了原始数据 target上。如果 value 是响应式数据，就意味着设置到原始对象上的也是响应式数据，我们把**响应式数据设置到原始数据上的行为称为数据污染**。

要解决数据污染也不难，只需要在调用 target.set 函数设置值之前对值进行检查即可：只要发现即将要设置的值是响应式数据，那么就通过 raw 属性获取原始数据，再把原始数据设置到 target 上，如下面的代码所示：

```javascript
const mutableInstrumentations = {
set(key, value) {
const target = this.raw
const had = target.has(key)
const oldValue = target.get(key)
// 获取原始数据，由于 value 本身可能已经是原始数据，所以此时value.raw 不存在，则直接使用 value
const rawValue = value.raw || value
target.set(key, rawValue)
if (!had) {
trigger(target, key, 'ADD')
} else if (oldValue !== value || (oldValue === oldValue &&
value === value)) {
trigger(target, key, 'SET')
}
}
}
```

现在的实现已经不会造成数据污染了。不过，细心观察上面的代
码，会发现新的问题。我们一直使用 raw 属性来访问原始数据是有缺
陷的，因为它可能与用户自定义的 raw 属性冲突，所以在一个严谨的
实现中，我们需要使用唯一的标识来作为访问原始数据的键，例如使
用 Symbol 类型来代替。

本节中，我们通过 Map 类型数据的 set 方法讲解了关于避免污染原始数据的问题。其实除了 set 方法需要避免污染原始数据之外，Set 类型的 add 方法、普通对象的写值操作，还有为数组添加元素的方法等，都需要做类似的处理。

### 处理 forEach

集合类型的 forEach 方法类似于数组的 forEach 方法，我们先来看看它是如何工作的：

```javascript
const m = new Map([
[{ key: 1 }, { value: 1 }]
])
04
effect(() => {
m.forEach(function (value, key, m) {
console.log(value) // { value: 1 }
console.log(key) // { key: 1 }
})
10 })
```

以 Map 为例，forEach 方法接收一个回调函数作为参数，该回调
函数会在 Map 的每个键值对上被调用。回调函数接收三个参数，分别
是值、键以及原始 Map 对象。如上面的代码所示，我们可以使用
forEach 方法遍历 Map 数据的每一组键值对。

遍历操作只与键值对的数量有关，因此任何会修改 Map 对象键值
对数量的操作都应该触发副作用函数重新执行，例如 delete 和 add
方法等。所以当 forEach 函数被调用时，我们应该让副作用函数与
ITERATE_KEY 建立响应联系，如下面的代码所示：

```javascript
const mutableInstrumentations = {
forEach(callback) {
// 取得原始数据对象
const target = this.raw
// 与 ITERATE_KEY 建立响应联系
track(target, ITERATE_KEY)
// 通过原始数据对象调用 forEach 方法，并把 callback 传递过去
target.forEach(callback)
}
}
```

这样我们就实现了对 forEach 操作的追踪，可以使用下面的代码进行测试：

```javascript
const p = reactive(new Map([
[{ key: 1 }, { value: 1 }]
]))
effect(() => {
p.forEach(function (value, key) {
console.log(value) // { value: 1 }
console.log(key) // { key: 1 }
})
})
// 能够触发响应
p.set({ key: 2 }, { value: 2 })
```

可以发现，这段代码能够按照预期工作。然而，上面给出的forEach 函数仍然存在缺陷，我们在自定义实现的 forEach 方法内，通过原始数据对象调用了原生的 forEach 方法，即:

```javascript
// 通过原始数据对象调用 forEach 方法，并把 callback 传递过去
target.forEach(callback)
```

这意味着，传递给 callback 回调函数的参数将是非响应式数据。这导致下面的代码不能按预期工作：

```javascript
const key = { key: 1 }
const value = new Set([1, 2, 3])
const p = reactive(new Map([
[key, value]
]))
effect(() => {
p.forEach(function (value, key) {
console.log(value.size) // 3
})
})
p.get(key).delete(1)
```

在上面这段代码中，响应式数据 p 有一个键值对，其中键是普通
对象 { key: 1 }，值是 Set 类型的原始数据 new Set([1, 2,
3])。接着，我们在副作用函数中使用 forEach 方法遍历 p，并在回
调函数中访问 value.size。最后，我们尝试删除 Set 类型数据中值
为 1 的元素，却发现没能触发副作用函数重新执行。导致问题的原因
就是上面曾提到的，当通过 value.size 访问 size 属性时，这里的
value 是原始数据对象，即 new Set([1, 2, 3])，而非响应式数
据对象，因此无法建立响应联系。但这其实不符合直觉，因为
reactive 本身是深响应，forEach 方法的回调函数所接收到的参数
也应该是响应式数据才对。为了解决这个问题，我们需要对现有实现
做一些修改，如下面的代码所示：

```javascript
const mutableInstrumentations = {
forEach(callback) {
// wrap 函数用来把可代理的值转换为响应式数据
const wrap = (val) => typeof val === 'object' ? reactive(val) : val
const target = this.raw
track(target, ITERATE_KEY)
// 通过 target 调用原始 forEach 方法进行遍历
target.forEach((v, k) => {
// 手动调用 callback，用 wrap 函数包裹 value 和 key 后再传给
callback，这样就实现了深响应
callback(wrap(v), wrap(k), this)
})
}
}
```

其实思路很简单，既然 callback 函数的参数不是响应式的，那
就将它转换成响应式的。所以在上面的代码中，我们又对 callback
函数的参数做了一层包装，即把传递给 callback 函数的参数包装成
响应式的。此时，如果再次尝试运行前文给出的例子，会发现它能够
按预期工作了。

最后，出于严谨性，我们还需要做一些补充。因为 forEach 函数
除了接收 callback 作为参数之外，它还接收第二个参数，该参数可
以用来指定 callback 函数执行时的 this 值。更加完善的实现如下
所示：

```javascript
const mutableInstrumentations = {
// 接收第二个参数
forEach(callback, thisArg) {
const wrap = (val) => typeof val === 'object' ? reactive(val) : val
const target = this.raw
track(target, ITERATE_KEY)
target.forEach((v, k) => {
// 通过 .call 调用 callback，并传递 thisArg
callback.call(thisArg, wrap(v), wrap(k), this)
})
}
}
```

至此，我们的工作仍然没有完成。现在我们知道，无论是使用
for...in 循环遍历一个对象，还是使用 forEach 循环遍历一个集
合，它们的响应联系都是建立在 ITERATE_KEY 与副作用函数之间
的。然而，使用 for...in 来遍历对象与使用 forEach 遍历集合之
间存在本质的不同。具体体现在，当使用 for...in 循环遍历对象
时，它只关心对象的键，而不关心对象的值，如以下代码所示：

```javascript
effect(() => {
for (const key in obj) {
console.log(key)
}
})
```

只有当新增、删除对象的 key 时，才需要重新执行副作用函数。
所以我们在 trigger 函数内判断操作类型是否是 ADD 或 DELETE，进
而知道是否需要触发那些与 ITERATE_KEY 相关联的副作用函数重新
执行。对于 SET 类型的操作来说，因为它不会改变一个对象的键的数
量，所以当 SET 类型的操作发生时，不需要触发副作用函数重新执行。

但这个规则不适用于 Map 类型的 forEach 遍历，如以下代码所示:

```javascript
const p = reactive(new Map([
['key', 1]
]))
effect(() => {
p.forEach(function (value, key) {
// forEach 循环不仅关心集合的键，还关心集合的值
console.log(value) // 1
})
})
p.set('key', 2) // 即使操作类型是 SET，也应该触发响应
```

当使用 forEach 遍历 Map 类型的数据时，它既关心键，又关心值。这意味着，当调用 p.set('key', 2) 修改值的时候，也应该触发副作用函数重新执行，即使它的操作类型是 SET。因此，我们应该修改 trigger 函数的代码来弥补这个缺陷：

```javascript
function trigger(target, key, type, newVal) {
console.log('trigger', key)
const depsMap = bucket.get(target)
if (!depsMap) return
const effects = depsMap.get(key)
const effectsToRun = new Set()
effects && effects.forEach(effectFn => {
if (effectFn !== activeEffect) {
effectsToRun.add(effectFn)
}
})
if (
type === 'ADD' ||
type === 'DELETE' ||
// 如果操作类型是 SET，并且目标对象是 Map 类型的数据，
// 也应该触发那些与 ITERATE_KEY 相关联的副作用函数重新执行
(
type === 'SET' &&
Object.prototype.toString.call(target) === '[object Map]'
)
) {
const iterateEffects = depsMap.get(ITERATE_KEY)
iterateEffects && iterateEffects.forEach(effectFn => {
if (effectFn !== activeEffect) {
effectsToRun.add(effectFn)
}
})
}
// 省略部分内容
effectsToRun.forEach(effectFn => {
if (effectFn.options.scheduler) {
effectFn.options.scheduler(effectFn)
} else {
effectFn()
}
})
}
```

如上面的代码所示，我们增加了一个判断条件：如果操作的目标对象是 Map 类型的，则 SET 类型的操作也应该触发那些与ITERATE_KEY 相关联的副作用函数重新执行。

### 迭代器方法

接下来，我们讨论关于集合类型的迭代器方法，实际上前面讲解如何拦截 for...of 循环遍历数组的时候介绍过迭代器的相关知识。集合类型有三个迭代器方法：

- entries
- keys
- values
  
调用这些方法会得到相应的迭代器，并且可以使用 for...of 进行循环迭代，例如：

```javascript
const m = new Map([
    ['key1', 'value1'],
    ['key2', 'value2']
])
for (const [key, value] of m.entries()) {
    console.log(key, value)
}
// 输出：
// key1 value1
// key2 value2
```

另外，由于 Map 或 Set 类型本身部署了 Symbol.iterator 方法，因此它们可以使用 for...of 进行迭代：

```javascript
for (const [key, value] of m) {
    console.log(key, value)
}
// 输出：
// key1 value1
// key2 value2
```

当然，我们也可以调用迭代器函数取得迭代器对象后，手动调用迭代器对象的 next 方法获取对应的值：

```javascript
const itr = m[Symbol.iterator]()
console.log(itr.next()) // { value: ['key1', 'value1'], done: false }
console.log(itr.next()) // { value: ['key2', 'value2'], done: false }
console.log(itr.next()) // { value: undefined, done: true }
```

实际上，m[Symbol.iterator] 与 m.entries 是等价的：

```javascript
console.log(m[Symbol.iterator] === m.entries) // true
```

这就是为什么上例中使用 for...of 循环迭代 m.entries 和 m 会得到同样的结果。

理解了这些内容后，我们就可以尝试实现对迭代器方法的代理了。不过在这之前，不妨做一些尝试，看看会发生什么，如以下代码所示：

```javascript
const p = reactive(new Map([
['key1', 'value1'],
['key2', 'value2']
]))
effect(() => {
// TypeError: p is not iterable
for (const [key, value] of p) {
console.log(key, value)
}
})
p.set('key3', 'value3')
```

在这段代码中，我们首先创建一个代理对象 p，接着尝试使用
for...of 循环遍历它，却得到了一个错误：“p 是不可迭代的”。我们
知道一个对象能否迭代，取决于该对象是否实现了迭代协议，如果一
个对象正确地实现了 Symbol.iterator 方法，那么它就是可迭代
的。很显然，代理对象 p 没有实现 Symbol.iterator 方法，因此我
们得到了上面的错误。

但实际上，当我们使用 for...of 循环迭代一个代理对象时，内
部会试图从代理对象 p 上读取 p[Symbol.iterator] 属性，这个操
作会触发 get 拦截函数，所以我们仍然可以把 Symbol.iterator 方
法的实现放到 mutableInstrumentations 中，如以下代码所示：

```javascript
const mutableInstrumentations = {
    [Symbol.iterator]() {
    // 获取原始数据对象 target
    const target = this.raw
    // 获取原始迭代器方法
    const itr = target[Symbol.iterator]()
    // 将其返回
    return itr
    }
}
```

实现很简单，不过是把原始的迭代器对象返回而已，这样就能够使用 for...of 循环迭代代理对象 p 了，然而事情不可能这么简单。
在处理forEach中讲解 forEach 方法时我们提到过，传递给 callback 的参数是包装后的响应式数据，如：

```javascript
p.forEach((value, key) => {
// value 和 key 如果可以被代理，那么它们就是代理对象，即响应式数据
})
```

同理，使用 for...of 循环迭代集合时，如果迭代产生的值也是可以被代理的，那么也应该将其包装成响应式数据，例如：

```javascript
for (const [key, value] of p) {
// 期望 key 和 value 是响应式数据
}
```

因此，我们需要修改代码：

```javascript
const mutableInstrumentations = {
    [Symbol.iterator]() {
        // 获取原始数据对象 target
        const target = this.raw
        // 获取原始迭代器方法
        const itr = target[Symbol.iterator]()
        const wrap = (val) => typeof val === 'object' && val !== null ? reactive(val) : val
        // 返回自定义的迭代器
        return {
            next() {
                // 调用原始迭代器的 next 方法获取 value 和 done
                const { value, done } = itr.next()
                return {
                    // 如果 value 不是 undefined，则对其进行包裹
                    value: value ? [wrap(value[0]), wrap(value[1])] : value,
                    done
                }
            }
        }
    }
}
```

如以上代码所示，为了实现对 key 和 value 的包装，我们需要自
定义实现的迭代器，在其中调用原始迭代器获取值 value 以及代表是
否结束的 done。如果值 value 不为 undefined，则对其进行包装，
最后返回包装后的代理对象，这样当使用 for...of 循环进行迭代
时，得到的值就会是响应式数据了。

最后，为了追踪 for...of 对数据的迭代操作，我们还需要调用track 函数，让副作用函数与 ITERATE_KEY 建立联系:

```javascript
const mutableInstrumentations = {
    [Symbol.iterator]() {
    const target = this.raw
    const itr = target[Symbol.iterator]()
    const wrap = (val) => typeof val === 'object' && val !== null ? reactive(val) : val
    // 调用 track 函数建立响应联系
    track(target, ITERATE_KEY)
        return {
            next() {
                const { value, done } = itr.next()
                return {
                    value: value ? [wrap(value[0]), wrap(value[1])] : value,
                    done
                }
            }
        }
    }
}
```

由于迭代操作与集合中元素的数量有关，所以只要集合的 size
发生变化，就应该触发迭代操作重新执行。因此，我们在调用 track
函数时让 ITERATE_KEY 与副作用函数建立联系。完成这一步后，集
合的响应式数据功能就相对完整了，我们可以通过如下代码测试一下：

```javascript
const p = reactive(new Map([
['key1', 'value1'],
['key2', 'value2']
]))
effect(() => {
    for (const [key, value] of p) {
        console.log(key, value)
    }
})
p.set('key3', 'value3') // 能够触发响应
```

前面我们说过，由于 p.entries 与 p[Symbol.iterator] 等价，所以我们可以使用同样的代码来实现对 p.entries 函数的拦截，如以下代码所示：

```javascript
const mutableInstrumentations = {
    // 共用 iterationMethod 方法
    [Symbol.iterator]: iterationMethod,
    entries: iterationMethod
}
// 抽离为独立的函数，便于复用
function iterationMethod() {
    const target = this.raw
    const itr = target[Symbol.iterator]()
    const wrap = (val) => typeof val === 'object' ? reactive(val) : val

    track(target, ITERATE_KEY)
    return {
        next() {
            const { value, done } = itr.next()
            return {
                value: value ? [wrap(value[0]), wrap(value[1])] : value,
                done
            }
        }
    }
}
```

但当你尝试运行代码使用 for...of 进行迭代时，会得到一个错误：

```javascript
// TypeError: p.entries is not a function or its return value is not iterable
for (const [key, value] of p.entries()) {
    console.log(key, value)
}
```

错误的大意是 p.entries 的返回值不是一个可迭代对象。很显
然，p.entries 函数的返回值是一个对象，该对象带有 next 方法，
但不具有 Symbol.iterator 方法，因此它确实不是一个可迭代对
象。这里是经常出错的地方，大家切勿把可迭代协议与迭代器协议搞
混。可迭代协议指的是一个对象实现了 Symbol.iterator 方法，而
迭代器协议指的是一个对象实现了 next 方法。但一个对象可以同时
实现可迭代协议和迭代器协议，例如：

```javascript
const obj = {
    // 迭代器协议
    next() {
    // ...
    }
    // 可迭代协议
    [Symbol.iterator]() {
        return this
    }
}
```

所以解决问题的方法也自然而然地出现了：

```javascript
// 抽离为独立的函数，便于复用
function iterationMethod() {
    const target = this.raw
    const itr = target[Symbol.iterator]()
    const wrap = (val) => typeof val === 'object' ? reactive(val) : val
    track(target, ITERATE_KEY)
    return {
        next() {
            const { value, done } = itr.next()
            return {
                value: value ? [wrap(value[0]), wrap(value[1])] : value,
                done
            }
        }
        // 实现可迭代协议
        [Symbol.iterator]() {
            return this
        }
    }
}
```

### values 与 keys 方法

values 方法的实现与 entries 方法类似，不同的是，当使用for...of 迭代 values 时，得到的仅仅是 Map 数据的值，而非键值对：

```javascript
for (const value of p.values()) {
console.log(value)
}
```

values 方法的实现如下：

```javascript
const mutableInstrumentations = {
    // 共用 iterationMethod 方法
    [Symbol.iterator]: iterationMethod,
    entries: iterationMethod,
    values: valuesIterationMethod
}
function valuesIterationMethod() {
    // 获取原始数据对象 target
    const target = this.raw
    // 通过 target.values 获取原始迭代器方法
    const itr = target.values()
    const wrap = (val) => typeof val === 'object' ? reactive(val) : val
    track(target, ITERATE_KEY)
    // 将其返回
    return {
        next() {
            const { value, done } = itr.next()
            return {
            // value 是值，而非键值对，所以只需要包裹 value 即可
            value: wrap(value),
            done
            }
        },
        [Symbol.iterator]() {
            return this
        }
    }
}
```

其中，valuesIterationMethod 与 iterationMethod 这两个方法有两点区别：

- iterationMethod 通过 target[Symbol.iterator] 获取迭代器对象，而 valuesIterationMethod 通过target.values 获取迭代器对象；
- iterationMethod 处理的是键值对，即 [wrap(value[0]),wrap(value[1])]，而 valuesIterationMethod 只处理值，即 wrap(value)。

由于它们的大部分逻辑相同，所以我们可以将它们封装到一个可复用的函数中。但为了便于理解，这里仍然将它们设计为两个独立的函数来实现。

keys 方法与 values 方法非常类似，不同点在于，前者处理的是键而非值。因此，我们只需要修改 valuesIterationMethod 方法中的一行代码，即可实现对 keys 方法的代理。把下面这句代码：

```javascript
const itr = target.values()
```

替换成

```javascript
const itr = target.keys()
```

这么做的确能够达到目的，但如果我们尝试运行如下测试用例，就会发现存在缺陷：

```javascript
const p = reactive(new Map([
['key1', 'value1'],
['key2', 'value2']
]))
effect(() => {
    for (const value of p.keys()) {
        console.log(value) // key1 key2
    }
})
p.set('key2', 'value3') // 这是一个 SET 类型的操作，它修改了 key2 的值
```

在上面这段代码中，我们使用 for...of 循环来遍历 p.keys，然后调用 p.set('key2', 'value3') 修改键为 key2 的值。
在这个过程中，Map 类型数据的所有键都没有发生变化，仍然是 key1 和 key2，所以在理想情况下，副作用函数不应该执行。但如果你尝试运行上例，会发现副作用函数仍然重新执行了。

这是因为，我们对 Map 类型的数据进行了特殊处理。前文提到，即使操作类型为 SET，也会触发那些与 ITERATE_KEY 相关联的副作用函数重新执行，trigger 函数的代码可以证明这一点：

```javascript
function trigger(target, key, type, newVal) {
    // 省略其他代码
    if (
    type === 'ADD' ||
    type === 'DELETE' ||
    // 即使是 SET 类型的操作，也会触发那些与 ITERATE_KEY 相关联的副作用函数重新执行
    (
    type === 'SET' &&
    Object.prototype.toString.call(target) === '[object Map]'
    )
    ) {
        const iterateEffects = depsMap.get(ITERATE_KEY)
        iterateEffects && iterateEffects.forEach(effectFn => {
            if (effectFn !== activeEffect) {
                effectsToRun.add(effectFn)
            }
        })
    }
}
```

这对于 values 或 entries 等方法来说是必需的，但对于 keys 方法来说则没有必要，因为 keys 方法只关心 Map 类型数据的键的变化，而不关心值的变化。

解决办法很简单，如以下代码所示：

```javascript
const MAP_KEY_ITERATE_KEY = Symbol()
function keysIterationMethod() {
    // 获取原始数据对象 target
    const target = this.raw
    // 获取原始迭代器方法
    const itr = target.keys()
    const wrap = (val) => typeof val === 'object' ? reactive(val) : val
    // 调用 track 函数追踪依赖，在副作用函数与 MAP_KEY_ITERATE_KEY 之间建立响应联系
    track(target, MAP_KEY_ITERATE_KEY)
    // 将其返回
    return {
        next() {
            const { value, done } = itr.next()
            return {
                value: wrap(value),
                done
            }
        },
        [Symbol.iterator]() {
            return this
        }
    }
}
```

在上面这段代码中，当调用 track 函数追踪依赖时，我们使用
MAP_KEY_ITERATE_KEY 代替了 ITERATE_KEY。其中
MAP_KEY_ITERATE_KEY 与 ITERATE_KEY 类似，是一个新的
Symbol 类型，用来作为抽象的键。这样就实现了依赖收集的分离，即
values 和 entries 等方法仍然依赖 ITERATE_KEY，而 keys 方法
则依赖 MAP_KEY_ITERATE_KEY。当 SET 类型的操作只会触发与
ITERATE_KEY 相关联的副作用函数重新执行时，自然就会忽略那些与
MAP_KEY_ITERATE_KEY 相关联的副作用函数。但当 ADD 和 DELETE
类型的操作发生时，除了触发与 ITERATE_KEY 相关联的副作用函数
重新执行之外，还需要触发与 MAP_KEY_ITERATE_KEY 相关联的副
作用函数重新执行，因此我们需要修改 trigger 函数的代码，如下所示：

```javascript
function trigger(target, key, type, newVal) {
// 省略其他代码
if (
// 操作类型为 ADD 或 DELETE
(type === 'ADD' || type === 'DELETE') &&
// 并且是 Map 类型的数据
Object.prototype.toString.call(target) === '[object Map]'
) {
    // 则取出那些与 MAP_KEY_ITERATE_KEY 相关联的副作用函数并执行
    const iterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY)
    iterateEffects && iterateEffects.forEach(effectFn => {
        if (effectFn !== activeEffect) {
            effectsToRun.add(effectFn)
        }
    })
}
}
```

这样，就能够避免不必要的更新了：

```javascript
const p = reactive(new Map([
['key1', 'value1'],
['key2', 'value2']
]))
effect(() => {
    for (const value of p.keys()) {
        console.log(value)
    }
})
p.set('key2', 'value3') // 不会触发响应
p.set('key3', 'value3') // 能够触发响应
```

## 总结

在本章中，我们首先介绍了 Proxy 与 Reflect。Vue.js 3 的响应
式数据是基于 Proxy 实现的，Proxy 可以为其他对象创建一个代理对
象。所谓代理，指的是对一个对象基本语义的代理。它允许我们拦截
并重新定义对一个对象的基本操作。在实现代理的过程中，我们遇到
了访问器属性的 this 指向问题，这需要使用 Reflect.* 方法并指定
正确的 receiver 来解决。

然后我们详细讨论了 JavaScript 中对象的概念，以及 Proxy 的工
作原理。在 ECMAScript 规范中，JavaScript 中有两种对象，其中一种
叫作常规对象，另一种叫作异质对象。满足以下三点要求的对象就是
常规对象：

- 对于表 5-1 给出的内部方法，必须使用规范 10.1.x 节给出的定义实现；
- 对于内部方法 [[Call]]，必须使用规范 10.2.1 节给出的定义实现；
- 对于内部方法 [[Construct]]，必须使用规范 10.2.2 节给出的定义实现。

而所有不符合这三点要求的对象都是异质对象。一个对象是函数还是其他对象，是由部署在该对象上的内部方法和内部槽决定的。

接着，我们讨论了关于对象 Object 的代理。代理对象的本质，
就是查阅规范并找到可拦截的基本操作的方法。有一些操作并不是基
本操作，而是复合操作，这需要我们查阅规范了解它们都依赖哪些基
本操作，从而通过基本操作的拦截方法间接地处理复合操作。我们还
详细分析了添加、修改、删除属性对 for...in 操作的影响，其中添
加和删除属性都会影响 for...in 循环的执行次数，所以当这些操作
发生时，需要触发与 ITERATE_KEY 相关联的副作用函数重新执行。
而修改属性值则不影响 for...in 循环的执行次数，因此无须处理。
我们还讨论了如何合理地触发副作用函数重新执行，包括对 NaN 的处
理，以及访问原型链上的属性导致的副作用函数重新执行两次的问
题。对于 NaN，我们主要注意的是 NaN === NaN 永远等于 false。
对于原型链属性问题，需要我们查阅规范定位问题的原因。由此可
见，想要基于 Proxy 实现一个相对完善的响应系统，免不了去了解
ECMAScript 规范

而后，我们讨论了深响应与浅响应，以及深只读与浅只读。这里
的深和浅指的是对象的层级，浅响应（或只读）代表仅代理一个对象
的第一层属性，即只有对象的第一层属性值是响应（或只读）的。深
响应（或只读）则恰恰相反，为了实现深响应（或只读），我们需要
在返回属性值之前，对值做一层包装，将其包装为响应式（或只读）
数据后再返回。

之后，我们讨论了关于数组的代理。数组是一个异质对象，因为
数组对象部署的内部方法 [[DefineOwnProperty]] 不同于常规对
象。通过索引为数组设置新的元素，可能会隐式地改变数组 length
属性的值。对应地，修改数组 length 属性的值，也可能会间接影响
数组中的已有元素。所以在触发响应的时候需要额外注意。我们还讨
论了如何拦截 for...in 和 for...of 对数组的遍历操作。使用
for...in 循环遍历数组与遍历普通对象区别不大，唯一需要注意的
是，当追踪 for...in 操作时，应该使用数组的 length 作为追踪的
key。for...of 基于迭代协议工作，数组内建了
Symbol.iterator 方法。根据规范的 23.1.5.1 节可知，数组迭代器
执行时，会读取数组的 length 属性或数组的索引。因此，我们不需
要做其他额外的处理，就能够实现对 for...of 迭代的响应式支持。
我们还讨论了数组的查找方法。如 includes、indexOf 以及
lastIndexOf 等。对于数组元素的查找，需要注意的一点是，用户既
可能使用代理对象进行查找，也可能使用原始对象进行查找。为了支
持这两种形式，我们需要重写数组的查找方法。原理很简单，当用户
使用这些方法查找元素时，我们可以先去代理对象中查找，如果找不
到，再去原始数组中查找。

我们还介绍了会隐式修改数组长度的原型方法，即 push、pop、
shift、unshift 以及 splice 等方法。调用这些方法会间接地读取
和设置数组的 length 属性，因此，在不同的副作用函数内对同一个
数组执行上述方法，会导致多个副作用函数之间循环调用，最终导致
调用栈溢出。为了解决这个问题，我们使用一个标记变量
shouldTrack 来代表是否允许进行追踪，然后重写了上述这些方法，
目的是，当这些方法间接读取 length 属性值时，我们会先将
shouldTrack 的值设置为 false，即禁止追踪。这样就可以断开
length 属性与副作用函数之间的响应联系，从而避免循环调用导致的
调用栈溢出。

最后，我们讨论了关于集合类型数据的响应式方案。集合类型指
Set、Map、WeakSet 以及 WeakMap。我们讨论了使用 Proxy 为集
合类型创建代理对象的一些注意事项。集合类型不同于普通对象，它
有特定的数据操作方法。当使用 Proxy 代理集合类型的数据时要格外
注意，例如，集合类型的 size 属性是一个访问器属性，当通过代理
对象访问 size 属性时，由于代理对象本身并没有部署 [[SetData]]
这样的内部槽，所以会发生错误。另外，通过代理对象执行集合类型
的操作方法时，要注意这些方法执行时的 this 指向，我们需要在
get 拦截函数内通过 .bind 函数为这些方法绑定正确的 this 值。我
们还讨论了集合类型响应式数据的实现。我们需要通过“重写”集合方
法的方式来实现自定义的能力，当 Set 集合的 add 方法执行时，需要
调用 trigger 函数触发响应。我们也讨论了关于“数据污染”的问题。
数据污染指的是不小心将响应式数据添加到原始数据中，它导致用户
可以通过原始数据执行响应式相关操作，这不是我们所期望的。为了
避免这类问题发生，我们通过响应式数据对象的 raw 属性来访问对应
的原始数据对象，后续操作使用原始数据对象就可以了。我们还讨论
了关于集合类型的遍历，即 forEach 方法。集合的 forEach 方法与
对象的 for...in 遍历类似，最大的不同体现在，当使用 for...in
遍历对象时，我们只关心对象的键是否变化，而不关心值；但使用
forEach 遍历集合时，我们既关心键的变化，也关心值的变化。