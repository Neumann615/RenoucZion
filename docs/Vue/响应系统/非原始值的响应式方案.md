## 非原始值的响应式方案

在上一章中，我们着重讨论了响应系统的概念与实现，并简单介
绍了响应式数据的基本原理。本章中我们把目光聚焦在响应式数据本
身，深入探讨实现响应式数据都需要考虑哪些内容，其中的难点又是
什么。实际上，实现响应式数据要比想象中难很多，并不是像上一章
讲述的那样，单纯地拦截 get/set 操作即可。举例来说，如何拦截
for...in 循环？track 函数如何追踪拦截到的 for...in 循环？类
似的问题还有很多。除此之外，我们还应该考虑如何对数组进行代
理。Vue.js 3 还支持集合类型，如 Map、Set、WeakMap 以及
WeakSet 等，那么应该如何对集合类型进行代理呢？实际上，想要实
现完善的响应式数据，我们需要深入语言规范。本章在揭晓答案的同
时，也会从语言规范的层面来分析原因，让你对响应式数据有更深入
的理解。

## 理解 Proxy 和 Reflect

既然 Vue.js 3 的响应式数据是基于 Proxy 实现的，那么我们就有
必要了解 Proxy 以及与之相关联的 Reflect。什么是 Proxy 呢？简
单地说，使用 Proxy 可以创建一个代理对象。它能够实现对其他对象
的代理，这里的关键词是其他对象，也就是说，Proxy 只能代理对
象，无法代理非对象值，例如字符串、布尔值等。那么，代理指的是
什么呢？所谓代理，指的是对一个对象基本语义的代理。它允许我们
拦截并重新定义对一个对象的基本操作。这句话的关键词比较多，我
们逐一解释。

什么是基本语义？给出一个对象 obj，可以对它进行一些操作，例如读取属性值、设置属性值：

```javascript
obj.foo // 读取属性 foo 的值
obj.foo++ // 读取和设置属性 foo 的值
```

类似这种读取、设置属性值的操作，就属于基本语义的操作，即基本操作。既然是基本操作，那么它就可以使用 Proxy 拦截：

```javascript
 const p = new Proxy(obj, {
    // 拦截读取属性操作
    get() { /*...*/
    },
    // 拦截设置属性操作
    set() { /*...*/
    }
})
```

如以上代码所示，Proxy 构造函数接收两个参数。第一个参数是被代理的对象，第二个参数也是一个对象，这个对象是一组夹子（trap）。其中
get 函数用来拦截读取操作，set 函数用来拦截设置操作。

在 JavaScript 的世界里，万物皆对象。例如一个函数也是一个对象，所以调用函数也是对一个对象的基本操作：

```javascript
const fn = (name) => {
    console.log('我是：', name)
}

// 调用函数是对对象的基本操作
fn()
```

因此，我们可以用 Proxy 来拦截函数的调用操作，这里我们使用apply 拦截函数的调用：

```javascript
 const p2 = new Proxy(fn, {
    // 使用 apply 拦截函数调用
    apply(target, thisArg, argArray) {
        target.call(thisArg, ...argArray)
    }
})

p2('hcy') // 输出：'我是：hcy'
```

上面两个例子说明了什么是基本操作。Proxy 只能够拦截对一个对象的基本操作。那么，什么是非基本操作呢？其实调用对象下的方法就是典型的非基本操作，我们叫它
**复合操作**：

```javascript
obj.fn()
```

实际上，调用一个对象下的方法，是由两个基本语义组成的。第
一个基本语义是 get，即先通过 get 操作得到 obj.fn 属性。第二个
基本语义是函数调用，即通过 get 得到 obj.fn 的值后再调用它，也
就是我们上面说到的 apply。理解 Proxy 只能够代理对象的基本语义
很重要，后续我们讲解如何实现对数组或 Map、Set 等数据类型的代
理时，都利用了 Proxy 的这个特点。

理解了 Proxy，我们再来讨论 Reflect。Reflect 是一个全局对象，其下有许多方法，例如:

```javascript
Reflect.get()
Reflect.set()
Reflect.apply()
//
```

你可能已经注意到了，Reflect 下的方法与 Proxy 的拦截器方
法名字相同，其实这不是偶然。任何在 Proxy 的拦截器中能够找到的
方法，都能够在 Reflect 中找到同名函数，那么这些函数的作用是什
么呢？其实它们的作用一点儿都不神秘。拿 Reflect.get 函数来
说，它的功能就是提供了访问一个对象属性的默认行为，例如下面两
个操作是等价的：

```javascript
const obj = {foo: 1}
// 直接读取
console.log(obj.foo) // 1
// 使用 Reflect.get 读取
console.log(Reflect.get(obj, 'foo')) // 1
```

可能有人会产生疑问：既然操作等价，那么它存在的意义是什么呢？实际上 Reflect.get 函数还能接收第三个参数，即指定接收者
receiver，你可以把它理解为函数调用过程中的 this，例如：

```javascript
const obj = {foo: 1}
console.log(Reflect.get(obj, 'foo', {foo: 2})) // 输出的是 2 而不是1
```

在这段代码中，我们指定第三个参数 receiver 为一个对象 {
foo: 2 }，这时读取到的值是 receiver 对象的 foo 属性值。实际
上，Reflect.* 方法还有很多其他方面的意义，但这里我们只关心并
讨论这一点，因为它与响应式数据的实现密切相关。为了说明问题，
回顾一下在上一节中实现响应式数据的代码：

```javascript
const obj = {foo: 1}
const p = new Proxy(obj, {
    get(target, key) {
        track(target, key)
        // 注意，这里我们没有使用 Reflect.get 完成读取
        return target[key]
    },
    set(target, key, newVal) {
        // 这里同样没有使用 Reflect.set 完成设置
        target[key] = newVal
        trigger(target, key)
    }
})
```

这是上一章中用来实现响应式数据的最基本的代码。在 get 和 set 拦截函数中，我们都是直接使用原始对象 target
来完成对属性的读取和设置操作的，其中原始对象 target 就是上述代码中的 obj对象。

那么这段代码有什么问题吗？我们借助 effect 让问题暴露出来。首先，我们修改一下 obj 对象，为它添加 bar 属性：

```javascript
const obj = {
    foo: 1,
    get bar() {
        return this.foo
    }
}
```

可以看到，bar 属性是一个访问器属性，它返回了 this.foo 属性的值。接着，我们在 effect 副作用函数中通过代理对象 p 访问 bar 属性：

```javascript
effect(() => {
    console.log(p.bar) // 1
})
```

我们来分析一下这个过程发生了什么。当 effect 注册的副作用
函数执行时，会读取 p.bar 属性，它发现 p.bar 是一个访问器属
性，因此执行 getter 函数。由于在 getter 函数中通过 this.foo
读取了 foo 属性值，因此我们认为副作用函数与属性 foo 之间也会建
立联系。当我们修改 p.foo 的值时应该能够触发响应，使得副作用函
数重新执行才对。然而实际并非如此，当我们尝试修改 p.foo 的值
时：

```javascript
p.foo++
```

副作用函数并没有重新执行，问题出在哪里呢？

实际上，问题就出在 bar 属性的访问器函数 getter 里：

```javascript
const obj = {
    foo: 1,
    get bar() {
        // 这里的 this 指向的是谁？
        return this.foo
    }
}
```

当我们使用 this.foo 读取 foo 属性值时，这里的 this 指向的是谁呢？我们回顾一下整个流程。首先，我们通过代理对象 p 访问
p.bar，这会触发代理对象的 get 拦截函数执行：

```javascript
const p = new Proxy(obj, {
    get(target, key) {
        track(target, key)
        //注意，这里我们没有使用 Reflect.get 完成读取
        return target[key]
    },
    // 省略部分代码
})
```

在 get 拦截函数内，通过 target[key] 返回属性值。其中
target 是原始对象 obj，而 key 就是字符串 'bar'，所以
target[key] 相当于 obj.bar。因此，当我们使用 p.bar 访问 bar
属性时，它的 getter 函数内的 this 指向的其实是原始对象 obj，
这说明我们最终访问的其实是 obj.foo。很显然，在副作用函数内通
过原始对象访问它的某个属性是不会建立响应联系的，这等价于：

```javascript
 effect(() => {
    // obj 是原始数据，不是代理对象，这样的访问不能够建立响应联系
    obj.foo
})
```

因为这样做不会建立响应联系，所以出现了无法触发响应的问题。那么这个问题应该如何解决呢？这时 Reflect.get 函数就派上用场了。先给出解决问题的代码：

```javascript
const p = new Proxy(obj, {
    // 拦截读取操作，接收第三个参数 receiver
    get(target, key, receiver) {
        track(target, key)
        // 使用 Reflect.get 返回读取到的属性值
        return Reflect.get(target, key, receiver)
    },
    // 省略部分代码
})
```

如上面的代码所示，代理对象的 get 拦截函数接收第三个参数receiver，它代表谁在读取属性，例如：

```javascript
 p.bar // 代理对象 p 在读取 bar 属性
```

当我们使用代理对象 p 访问 bar 属性时，那么 receiver 就是
p，你可以把它简单地理解为函数调用中的 this。接着关键的一步发
生了，我们使用 Reflect.get(target, key, receiver) 代替
之前的 target[key]，这里的关键点就是第三个参数 receiver。
我们已经知道它就是代理对象 p，所以访问器属性 bar 的 getter 函
数内的 this 指向代理对象 p：

```javascript
const obj = {
    foo: 1,
    get bar() {
        // 现在这里的 this 为代理对象 p
        return this.foo
    }
}
```

可以看到，this 由原始对象 obj 变成了代理对象 p。很显然，这
会在副作用函数与响应式数据之间建立响应联系，从而达到依赖收集
的效果。如果此时再对 p.foo 进行自增操作，会发现已经能够触发副
作用函数重新执行了。

正是基于上述原因，后文讲解中将统一使用 Reflect.* 方法

## JavaScript 对象及 Proxy 的工作原理

我们经常听到这样的说法：“JavaScript 中一切皆对象。”那么，到
底什么是对象呢？这个问题需要我们查阅 ECMAScript 规范才能得到答
案。实际上，根据 ECMAScript 规范，在 JavaScript 中有两种对象，其
中一种叫作常规对象（ordinary object），另一种叫作异质对象
（exotic object）。这两种对象包含了 JavaScript 世界中的所有对象，任
何不属于常规对象的对象都是异质对象。那么到底什么是常规对象，
什么是异质对象呢？这需要我们先了解对象的内部方法和内部槽。

我们知道，在 JavaScript 中，函数其实也是对象。假设给出一个对
象 obj，如何区分它是普通对象还是函数呢？实际上，在 JavaScript
中，对象的实际语义是由对象的内部方法（internal method）指定的。
所谓内部方法，指的是当我们对一个对象进行操作时在引擎内部调用
的方法，这些方法对于 JavaScript 使用者来说是不可见的。举个例子，
当我们访问对象属性时：

```javascript
obj.foo
```

引擎内部会调用 `Get` 这个内部方法来读取属性值。这里补充说明一下，在 ECMAScript 规范中使用 `xxx`
来代表内部方法或内部槽。当然，一个对象不仅部署了 `Get`这个内部方法，以下列出了规范要求的所有必要的内部方法。

| 内部方法                |                                                            描述                                                             |
|---------------------|:-------------------------------------------------------------------------------------------------------------------------:|
| `GetPrototypeOf`    |                                               查明为该对象提供继承属性的对象，null 代表没有继承属性                                               |
| `SetPrototypeOf`    |                          将该对象与提供继承属性的另一个对象相关联。传递 null 表示没有继承属性，返回 true 表示操作成功完成，返回 false 表示操作失败                           |
| `IsExtensible`      |                                                     查明是否允许向该对象添加其他属性                                                      |
| `PreventExtensions` |                                       控制能否向该对象添加新属性。如果操作成功则返回 true，如果操作失败 则返回 false                                       |
| `GetOwnProperty`    |                                  返回该对象自身属性的描述符，其键为 propertyKey，如果不存在这样的属性，则返回 undefined                                   |
| `DefineOwnProperty` |            创建或更改自己的属性，其键为propertyKey，以具有由PropertyDescriptor 描述的状态。如果该属性已成功创建或更新，则返回true；如果无法创建或更新该属性，则返回 false            |
| `HasProperty`       |                                       返回一个布尔值，指示该对象是否已经拥有键为 propertyKey 的自己的或继承的属性                                        |
| `Get`               |                     从该对象返回键为 propertyKey 的属性的值。如果必须运行 ECMAScript代码来检索属性值，则在运行代码时使用 Receiver 作为 this 值                     |
| `Set`               | 将键值为 propertyKey 的属性的值设置为 value。如果必须运行ECMAScript 代码来设置属性值，则在运行代码时使用 Receiver 作为this 值。如果成功设置了属性值，则返回 true；如果无法设置，则返回false |
| `Delete`            |                       从该对象中删除属于自身的键为propertyKey 的属性。如果该属性未被删除并且仍然存在，则返回false；如果该属性已被删除或不存在，则返回 true                       |
| `OwnPropertyKeys`   |                                                  返回一个 List，其元素都是对象自身的属性键                                                  |

包括 `Get` 在内，一个对象必须部署 11 个必要的内部方法。还有两个额外的必要内部方法 ：`Call` 和 `Construct`

| 内部方法        |                                                           描述                                                           |
|-------------|:----------------------------------------------------------------------------------------------------------------------:|
| `Call`      |                                   将运行的代码与 this 对象关联。由函数调用触发。该内部方法的参数是一个 this 值和参数列表                                    |
| `Construct` | 创建一个对象。通过 new 运算符或 super 调用触发。该内部方法的第一个参数是一个 List，该 List 的元素是构造函数调用或 super 调用的参数，第二个参数是最初应用new 运算符的对象。实现该内部方法的对象称为构造函数 |

如果一个对象需要作为函数调用，那么这个对象就必须部署内部
方法 `Call`。现在我们就可以回答前面的问题了：如何区分一个
对象是普通对象还是函数呢？一个对象在什么情况下才能作为函数调
用呢？答案是，通过内部方法和内部槽来区分对象，例如函数对象会
部署内部方法 `Call`，而普通对象则不会。

内部方法具有多态性，这是什么意思呢？这类似于面向对象里多
态的概念。这就是说，不同类型的对象可能部署了相同的内部方法，
却具有不同的逻辑。例如，普通对象和 Proxy 对象都部署了
`Get` 这个内部方法，但它们的逻辑是不同的，普通对象部署的
`Get` 内部方法的逻辑是由 ECMA 规范的 10.1.8 节定义的，而
Proxy 对象部署的 `Get` 内部方法的逻辑是由 ECMA 规范的
10.5.8 节来定义的。

了解了内部方法，就可以解释什么是常规对象，什么是异质对象了。满足以下三点要求的对象就是常规对象:

- 对象必要的内部方法，必须使用 ECMA 规范 10.1.x 节给出的定义实现；
- 对于内部方法 `Call`，必须使用 ECMA 规范 10.2.1 节给出的定义实现；
- 对于内部方法 `Construct`，必须使用 ECMA 规范 10.2.2 节给出的定义实现。

而所有不符合这三点要求的对象都是**异质对象(外来对象)**。例如，由于Proxy 对象的内部方法 `Get` 没有使用 ECMA 规范的 10.1.8
节给出的定义实现，所以 Proxy 是一个异质对象。

现在我们对 JavaScript 中的对象有了更加深入的理解。接下来，我们就具体看看 Proxy 对象。既然 Proxy
也是对象，那么它本身也部署了上述必要的内部方法，当我们通过代理对象访问属性值时：

```javascript
const p = new Proxy(obj, {/* ... */})
p.foo
```

实际上，引擎会调用部署在对象 p 上的内部方法 `Get`。到这
一步，其实代理对象和普通对象没有太大区别。它们的区别在于对于
内部方法 `Get` 的实现，这里就体现了内部方法的多态性，即不同
的对象部署相同的内部方法，但它们的行为可能不同。具体的不同体
现在，如果在创建代理对象时没有指定对应的拦截函数，例如没有指
定 get() 拦截函数，那么当我们通过代理对象访问属性值时，代理对
象的内部方法 `Get` 会调用原始对象的内部方法 `Get` 来获取
属性值，这其实就是代理透明性质。

现在相信你已经明白了，创建代理对象时指定的拦截函数，实际上是用来自定义代理对象本身的内部方法和行为的，而不是用来指定被代理对象的内部方法和行为的。以下列出了
Proxy 对象部署的所有内部方法以及用来自定义内部方法和行为的拦截函数名字。

| 内部方法                |          处理器函数           |
|---------------------|:------------------------:|
| `GetPrototypeOf`    |      getPrototypeOf      |
| `SetPrototypeOf`    |      setPrototypeOf      |
| `IsExtensible`      |       isExtensible       |
| `PreventExtensions` |    preventExtensions     |
| `GetOwnProperty`    | getOwnPropertyDescriptor |
| `DefineOwnProperty` |      defineProperty      |
| `HasProperty`       |           has            |
| `Get`               |           get            |
| `Set`               |           set            |
| `Delete`            |      deleteProperty      |
| `OwnPropertyKeys`   |         ownKeys          |
| `Call`              |          apply           |
| `Construct`         |        construct         |

当然，其中 `Call` 和 `Construct` 这两个内部方法只有当被代理的对象是函数和构造函数时才会部署。

当我们要拦截删除属性操作时，可以使用 deleteProperty 拦截函数实现：

```javascript
const obj = {foo: 1}
const p = new Proxy(obj, {
    deleteProperty(target, key) {
        return Reflect.deleteProperty(target, key)
    }
})

console.log(p.foo) // 1
delete p.foo
console.log(p.foo) // 未定义
```

这里需要强调的是，deleteProperty 实现的是代理对象 p
的内部方法和行为，所以为了删除被代理对象上的属性值，我们需要使用Reflect.deleteProperty(target, key) 来完成。

## 如何代理Object

从本节开始，我们将着手实现响应式数据。前面我们使用 get 拦
截函数去拦截对属性的读取操作。但在响应系统中，“读取”是一个很
宽泛的概念，例如使用 in 操作符检查对象上是否具有给定的 key 也
属于“读取”操作，如下面的代码所示

```javascript
 effect(() => {
    'foo' in obj
})
```

这本质上也是在进行“读取”操作。响应系统应该拦截一切读取操作，以便当数据变化时能够正确地触发响应。下面列出了对一个普通对象的所有可能的读取操作。

- 访问属性：obj.foo。
- 判断对象或原型上是否存在给定的 key：key in obj。
- 使用 for...in 循环遍历对象：for (const key in obj){}。

接下来，我们逐步讨论如何拦截这些读取操作。首先是对于属性的读取，例如 obj.foo，我们知道这可以通过 get 拦截函数实现：

```javascript
const obj = {foo: 1}

const p = new Proxy(obj, {
    get(target, key, receiver) {
        // 建立联系
        track(target, key)
        // 返回属性值
        return Reflect.get(target, key, receiver)
    },
})
```

in操作符的运行时逻辑：

![avatar](/Vue/images/第135页-29.png)

1. 让 lref 的值为 RelationalExpression 的执行结果。
2. 让 lval 的值为 ? GetValue(lref)。
3. 让 rref 的值为 ShiftExpression 的执行结果。
4. 让 rval 的值为 ? GetValue(rref)。
5. 如果 Type(rval) 不是对象，则抛出 TypeError 异常。
6. 返回 ? HasProperty(rval, ? ToPropertyKey(lval))

关键点在第 6 步，可以发现，in 操作符的运算结果是通过调用一个叫作 HasProperty 的抽象方法得到的。关于 HasProperty 抽象方法，可以在
ECMA-262 规范的 7.3.11 节中找到。

![avatar](/Vue/images/第136页-30.png)

1. 断言：Type(O) 是 Object。
2. 断言：IsPropertyKey(P) 是 true。
3. 返回 ? O.`HasProperty`(P)。

在第 3 步中，可以看到 HasProperty 抽象方法的返回值是通过调用对象的内部方法 `HasProperty` 得到的。它对应的拦截函数名叫
has，因此我们可以通过 has 拦截函数实现对 in 操作符的代理：

```javascript
const obj = {foo: 1}
const p = new Proxy(obj, {
    has(target, key) {
        track(target, key)
        return Reflect.has(target, key)
    }
})
```

这样，当我们在副作用函数中通过 in 操作符操作响应式数据时，就能够建立依赖关系：

```javascript
effect(() => {
    'foo' in p // 将会建立依赖关系
})
```

再来看看如何拦截 for...in 循环。上文列出的是一个对象的所有基本语义方法，也就是说，任何操作其实都是由这些基本语义方法及其组合实现的，
for...in 循环也不例外。为了搞清楚
for...in循环依赖哪些基本语义方法，还需要看规范。

![avatar](/Vue/images/第137页-31.png)

第 6 步描述的内容如下。

如果 iterationKind 是枚举（enumerate），则

- a. 如果 exprValue 是 undefined 或 null，那么 i. 返回 Completion { `Type`: break,`Value`: empty, `Target`: empty }。
- b. 让 obj 的值为 ! ToObject(exprValue)。
- c. 让 iterator 的值为 ? EnumerateObjectProperties(obj)。
- d. 让 nextMethod 的值为 ! GetV(iterator,"next")。
- e. 返回 Record{ `Iterator`: iterator,`NextMethod`: nextMethod, `Done`: false }。

仔细观察第 6 步的第 c 子步骤：

让 iterator 的值为 ? EnumerateObjectProperties(obj)。

其中的关键点在于 EnumerateObjectProperties(obj)。这里的 EnumerateObjectProperties 是一个抽象方法，该方法返回一个迭代器对象，规范的
14.7.5.9
节给出了满足该抽象方法的示例实现，如下面的代码所示：

```javascript
function* EnumerateObjectProperties(obj) {
    const visited = new Set()
    for (const key of Reflect.ownKeys(obj)) {
        if (typeof key === "symbol") continue
        const desc = Reflect.getOwnPropertyDescriptor(obj, key)
        if (desc) {
            visited.add(key)
            if (desc.enumerable) yield key
        }
    }
    const proto = Reflect.getPrototypeOf(obj)
    if (proto === null) return
    for (const protoKey of EnumerateObjectProperties(proto)) {
        if (!visited.has(protoKey)) yield protoKey
    }
}
```

可以看到，该方法是一个 generator 函数，接收一个参数
obj。实际上，obj 就是被 for...in 循环遍历的对象，其关键点在
于使用 Reflect.ownKeys(obj) 来获取只属于对象自身拥有的键。
有了这个线索，如何拦截 for...in 循环的答案已经很明显了，我们
可以使用 ownKeys 拦截函数来拦截 Reflect.ownKeys 操作：

```javascript
const obj = {foo: 1}
const ITERATE_KEY = Symbol()
const p = new Proxy(obj, {
    ownKeys(target) {
        // 将副作用函数与 ITERATE_KEY 关联
        track(target, ITERATE_KEY)
        return Reflect.ownKeys(target)
    }
})
```

如上面的代码所示，拦截 ownKeys 操作即可间接拦截 for...in
循环。但相信大家已经注意到了，我们在使用 track 函数进行追踪的
时候，将 ITERATE_KEY 作为追踪的 key，为什么这么做呢？这是因
为 ownKeys 拦截函数与 get/set 拦截函数不同，在 set/get 中，我
们可以得到具体操作的 key，但是在 ownKeys 中，我们只能拿到目标
对象 target。这也很符合直觉，因为在读写属性值时，总是能够明确
地知道当前正在操作哪一个属性，所以只需要在该属性与副作用函数
之间建立联系即可。而 ownKeys 用来获取一个对象的所有属于自己的
键值，这个操作明显不与任何具体的键进行绑定，因此我们只能够构
造唯一的 key 作为标识，即 ITERATE_KEY。

既然追踪的是 ITERATE_KEY，那么相应地，在触发响应的时候也应该触发它才行:

```javascript
 trigger(target, ITERATE_KEY)
```

但是在什么情况下，对数据的操作需要触发与 ITERATE_KEY 相关联的副作用函数重新执行呢？为了搞清楚这个问题，我们用一段代码来说明。假设副作用函数内有一段
for...in 循环：

```javascript
const obj = {foo: 1}
const p = new Proxy(obj, {/* ... */})

effect(() => {
    // for...in 循环
    for (const key in p) {
        console.log(key) // foo
    }
})
```

副作用函数执行后，会与 ITERATE_KEY 之间建立响应联系，接下来我们尝试为对象 p 添加新的属性 bar：

```javascript
p.bar = 2
```

由于对象 p 原本只有 foo 属性，因此 for...in 循环只会执行一
次。现在为它添加了新的属性 bar，所以 for...in 循环就会由执行
一次变成执行两次。也就是说，当为对象添加新属性时，会对
for...in 循环产生影响，所以需要触发与 ITERATE_KEY 相关联的
副作用函数重新执行。但目前的实现还做不到这一点。当我们为对象 p
添加新的属性 bar 时，并没有触发副作用函数重新执行，这是为什么
呢？我们来看一下现在的 set 拦截函数的实现：

```javascript
const p = new Proxy(obj, {
    // 拦截设置操作
    set(target, key, newVal, receiver) {
        // 设置属性值
        const res = Reflect.set(target, key, newVal, receiver)
        // 把副作用函数从桶里取出并执行
        trigger(target, key)

        return res
    },
    // 省略其他拦截函数
})
```

当为对象 p 添加新的 bar 属性时，会触发 set 拦截函数执行。此
时 set 拦截函数接收到的 key 就是字符串 'bar'，因此最终调用
trigger 函数时也只是触发了与 'bar' 相关联的副作用函数重新执
行。但根据前文的介绍，我们知道 for...in 循环是在副作用函数与
ITERATE_KEY 之间建立联系，这和 'bar' 一点儿关系都没有，因此
当我们尝试执行 p.bar = 2 操作时，并不能正确地触发响应。

弄清楚了问题在哪里，解决方案也就随之而来了。当添加属性时，我们将那些与 ITERATE_KEY 相关联的副作用函数也取出来执行就可以了：

```javascript
function trigger(target, key) {
    const depsMap = bucket.get(target)
    if (!depsMap) return
    // 取得与 key 相关联的副作用函数
    const effects = depsMap.get(key)
    // 取得与 ITERATE_KEY 相关联的副作用函数
    const iterateEffects = depsMap.get(ITERATE_KEY)

    const effectsToRun = new Set()
    // 将与 key 相关联的副作用函数添加到 effectsToRun
    effects && effects.forEach(effectFn => {
        if (effectFn !== activeEffect) {
            effectsToRun.add(effectFn)
        }
    })
    // 将与 ITERATE_KEY 相关联的副作用函数也添加到 effectsToRun
    iterateEffects && iterateEffects.forEach(effectFn => {
        if (effectFn !== activeEffect) {
            effectsToRun.add(effectFn)
        }
    })

    effectsToRun.forEach(effectFn => {
        if (effectFn.options.scheduler) {
            effectFn.options.scheduler(effectFn)
        } else {
            effectFn()
        }
    })
}
```

如以上代码所示，当 trigger 函数执行时，除了把那些直接与具体操作的 key 相关联的副作用函数取出来执行外，还要把那些与ITERATE_KEY
相关联的副作用函数取出来执行。

但对于添加新的属性来说，这么做没有什么问题，但如果仅仅修改已有属性的值，而不是添加新属性，那么问题就来了。看如下代码：

```javascript
const obj = {foo: 1}
const p = new Proxy(obj, {/* ... */})

effect(() => {
    // for...in 循环
    for (const key in p) {
        console.log(key) // foo
    }
})
```

当我们修改 p.foo 的值时：

```javascript
obj.foo = 2
```

与添加新属性不同，修改属性不会对 for...in 循环产生影响。
因为无论怎么修改一个属性的值，对于 for...in 循环来说都只会循
环一次。所以在这种情况下，我们不需要触发副作用函数重新执行，
否则会造成不必要的性能开销。然而无论是添加新属性，还是修改已
有的属性值，其基本语义都是 `Set`，我们都是通过 set 拦截函数
来实现拦截的，如以下代码所示：

```javascript
const p = new Proxy(obj, {
    // 拦截设置操作
    set(target, key, newVal, receiver) {
        // 设置属性值
        const res = Reflect.set(target, key, newVal, receiver)
        // 把副作用函数从桶里取出并执行
        trigger(target, key)

        return res
    },
    // 省略其他拦截函数
})
```

所以要想解决上述问题，当设置属性操作发生时，就需要我们在set 拦截函数内能够区分操作的类型，到底是添加新属性还是设置已有属性:

```javascript
 const p = new Proxy(obj, {
    // 拦截设置操作
    set(target, key, newVal, receiver) {
        // 如果属性不存在，则说明是在添加新属性，否则是设置已有属性
        const type = Object.prototype.hasOwnProperty.call(target,
            key) ? 'SET' : 'ADD'

        // 设置属性值
        const res = Reflect.set(target, key, newVal, receiver)

        // 将 type 作为第三个参数传递给 trigger 函数
        trigger(target, key, type)

        return res
    },
    // 省略其他拦截函数
})
```

如以上代码所示，我们优先使用
Object.prototype.hasOwnProperty 检查当前操作的属性是否已
经存在于目标对象上，如果存在，则说明当前操作类型为 'SET'，即
修改属性值；否则认为当前操作类型为 'ADD'，即添加新属性。最
后，我们把类型结果 type 作为第三个参数传递给 trigger 函数。

在 trigger 函数内就可以通过类型 type 来区分当前的操作类型，并且只有当操作类型 type 为 'ADD' 时，才会触发与ITERATE_KEY
相关联的副作用函数重新执行，这样就避免了不必要的性能损耗：

```javascript
function trigger(target, key, type) {
    const depsMap = bucket.get(target)
    if (!depsMap) return
    const effects = depsMap.get(key)

    const effectsToRun = new Set()
    effects && effects.forEach(effectFn => {
        if (effectFn !== activeEffect) {
            effectsToRun.add(effectFn)
        }
    })
    console.log(type, key)
    // 只有当操作类型为 'ADD' 时，才触发与 ITERATE_KEY 相关联的副作用函数重新执行
    if (type === 'ADD') {
        const iterateEffects = depsMap.get(ITERATE_KEY)
        iterateEffects && iterateEffects.forEach(effectFn => {
            if (effectFn !== activeEffect) {
                effectsToRun.add(effectFn)
            }
        })
    }

    effectsToRun.forEach(effectFn => {
        if (effectFn.options.scheduler) {
            effectFn.options.scheduler(effectFn)
        } else {
            effectFn()
        }
    })
}
```

关于对象的代理，还剩下最后一项工作需要做，即删除属性操作的代理：

```javascript
 delete p.foo
```

如何代理 delete 操作符呢？还是看规范，规范的 13.5.1.2 节中明确定义了 delete 操作符的行为。

![avatar](/Vue/images/第145页-32.png)

的第 5 步描述的内容如下。

如果 IsPropertyReference(ref) 是 true，那么

- a. 断言：! IsPrivateReference(ref) 是 false。
- b. 如果 IsSuperReference(ref) 也是 true，则抛出 ReferenceError 异常。
- c. 让 baseObj 的值为 ! ToObject(ref,`Base`)。
- d. 让 deleteStatus 的值为 ? baseObj.`Delete`(ref.`ReferencedName`)。
- e. 如果 deleteStatus 的值为 false 并且 ref.`Strict` 的值是 true，则抛出 TypeError 异常。
- f. 返回 deleteStatus。

由第 5 步中的 d 子步骤可知，delete 操作符的行为依赖`Delete`内部方法。接着上文对应表，该内部方法可以使用`deleteProperty`拦截：

```javascript
 const p = new Proxy(obj, {
    deleteProperty(target, key) {
        // 检查被操作的属性是否是对象自己的属性
        const hadKey = Object.prototype.hasOwnProperty.call(target, key)
        // 使用 Reflect.deleteProperty 完成属性的删除
        const res = Reflect.deleteProperty(target, key)

        if (res && hadKey) {
            // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新
            trigger(target, key, 'DELETE')
        }

        return res
    }
})
```

如以上代码所示，首先检查被删除的属性是否属于对象自身，然
后调用 Reflect.deleteProperty 函数完成属性的删除工作，只有
当这两步的结果都满足条件时，才调用 trigger 函数触发副作用函数
重新执行。需要注意的是，在调用 trigger 函数时，我们传递了新的
操作类型 'DELETE'。由于删除操作会使得对象的键变少，它会影响
for...in 循环的次数，因此当操作类型为 'DELETE' 时，我们也应
该触发那些与 ITERATE_KEY 相关联的副作用函数重新执行：

```javascript
 function trigger(target, key, type) {
    const depsMap = bucket.get(target)
    if (!depsMap) return
    const effects = depsMap.get(key)

    const effectsToRun = new Set()
    effects && effects.forEach(effectFn => {
        if (effectFn !== activeEffect) {
            effectsToRun.add(effectFn)
        }
    })

    // 当操作类型为 ADD 或 DELETE 时，需要触发与 ITERATE_KEY 相关联的副作用函数重新执行
    if (type === 'ADD' || type === 'DELETE') {
        const iterateEffects = depsMap.get(ITERATE_KEY)
        iterateEffects && iterateEffects.forEach(effectFn => {
            if (effectFn !== activeEffect) {
                effectsToRun.add(effectFn)
            }
        })
    }

    effectsToRun.forEach(effectFn => {
        if (effectFn.options.scheduler) {
            effectFn.options.scheduler(effectFn)
        } else {
            effectFn()
        }
    })
}
```

在这段代码中，我们添加了 type === 'DELETE' 判断，使得删除属性操作能够触发与 ITERATE_KEY 相关联的副作用函数重新执行。

## 合理地触发响应

上一节中，我们从规范的角度详细介绍了如何代理对象，在这个过程中，处理了很多边界条件。例如，我们需要明确知道操作的类型是'AD0'
还是'SET'，抑或是其他操作类型，从而正确地触发响应。但想要合理地触发响应，还有许多工作要做。
首先，我们来看要面临的第一个问题，即当值没有发生变化时，应该不需要触发响应才对:

```javascript
const obj = {foo: 1}
const p = new Proxy(obj, {})

effect(() => {
    console.log(p.foo)
})

// 设置p.foo的值，但值没有变化
p.foo = 1
```

如上面的代码所示，p.foo的初始值为1,当为p.foo设置新的值时，如果值没有发生变化，则不需要触发响应。为了满足需求，我们需要修改
set拦截函数的代码，在调用trigger函数触发响应之前，需要检查值是否真的发生了变化:

```javascript
const p = new Proxy(obj, {
    set(target, key, newValue, receiver) {
        const oldValue = target[key]
        const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
        const res = Reflect.set(target, key, newValue, receiver)
        if (oldValue !== newValue) {
            trigger(target, key, type)
        }
        return res
    }
})
```

如上面的代码所示，我们在set拦截函数内首先获取旧值aldval，接着比较新值与旧值，只有当它们不全等的时候才触发响应。现在，如果我们再次测试本节开头的例子，会发现重新设置相同的值已经不会触发响应了。
然而，仅仅进行全等比较是有缺陷的，这体现在对NaN的处理上。我们知道NaN与NaN进行全等比较总会得到 false:

```javascript
NaN === NaN // false
NaN !== NaN // true
```

换句话说、如果p.foo的初始值是NaN，并且后续又为其设置了NaN作为新值，那么仅仅进行全等比较的缺陷就暴露了:

```javascript
const obj = {foo: NaN}
const p = new Proxy(obj, {})

effect(() => {
    console.log(p.foo)
})

// 依旧会触发响应
p.foo = NaN
```

这仍然会触发响应，并导致不必要的更新。为了解决这个问题，我们需要再加一个条件，即在新值和旧值不全等的情况下，要保证它们都不是NaN:

```javascript
const p = new Proxy(obj, {
    set(target, key, newValue, receiver) {
        const oldValue = target[key]
        const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
        const res = Reflect.set(target, key, newValue, receiver)
        if (oldValue !== newValue && (oldValue === oldValue || newValue === newValue)) {
            trigger(target, key, type)
        }
        return res
    }
})
```

这样我们就解决了NaN的问题。但想要合理地触发响应，仅仅处理关于NaN的问题还不够。接下来，我们讨论一种从原型上继承属性的情况。为了后续讲解方便，我们需要封装一个reactive函数，该函数接收一个对象作为参数，并返回为其创建的响应式数据:

```javascript
function reactive(obj) {
    return new Proxy(obj, {})
}
```

可以看到，reactive函数只是对Proxy进行了一层封装。接下来，我们基于reactive创建一个例子:

```javascript
const obj = {}
const proto = {bar: 1}
const child = reactive(obj)
const parent = reactive(proto)
Object.setPrototypeOf(child, parent)

effect(() => {
    console.log(child, bar) // 1
})

child.bar = 2 // 会导致副作用函数重新执行两次
```

观察如上代码，我们定义了空对象obj和对象proto，分别为二者创建了对应的响应式数据child和parent,并且使用object.setPrototypeof
方法将parent设置为child的原型。接着在副作用函数内访问child.bar的值。从代码中可以看出，child本身并没有bar属性，因此当访问child.bar时，
值是从原型上继承而来的。但无论如何，既然child是响应式数据，那么它与副作用函数之间就会建立联系，因此当我们执行child.bar=2时，期望副作用函数会重新执行。
但如果你尝试运行上面的代码，会发现副作用函数不仅执行了，还执行了两次，这会造成不必要的更新。
为了搞清楚问题的原因，我们需要逐步分析整个过程。当在副作用函数中读取child.bar的值时，会触发child代理对象的get拦截函数。我们知道，在拦截函数内是使用Reflect.get(
target,key，receiver)来得到最终结果的，对应到上例，这句话相当于:

```javascript
Reflect.get(obj, 'bar', receiver)
```

这其实是实现了通过obj.bar来访问属性值的默认行为。也就是说，引擎内部是通过调用obj对象所部署的[[Get]]
内部方法来得到最终结果的，因此我们有必要查看规范10.1.8.1节来了解[[Get]]内部方法的执行流程。

![avatar](/Vue/images/第151页-33.png)

```text
3.如果desc是undefined,那么:
  a.让 parent 的值为?0.[[GetPrototypeOf]]()。
  b.如o果parent 是 null,则返回 undefined.
  c. 返回? parent.[[Get]](P,Receiver)。
```

第3步中，我们能够了解到非常关键的信息，即如果对象自身不存在该属性，那么会获取对象的原型，并调用原型的[[Get]]
方法得到最终结果。对应到上例中，当读取child.bar属性值时，由于child代理的对象obj自身没有bar属性，因此会获取对象obj的原型，也就是parent对象，所以最终得到的实际上是parent.bar的值。
但是大家不要忘了，parent本身也是响应式数据，因此在副作用函数中访问parent.bar的值时，会导致副作用函数被收集，从而也建立响应联系。所以我们能够得出一个结论，即child.bar和parent.bar都与副作用函数建立了响应联系。

但这仍然解释不了为什么当设置child.bar的值时，会连续触发两次副作用函数执行，所以接下来我们需要看看当设置操作发生时的具体执行流程。
我们知道，当执行child.bar=2时，会调用child代理对象的set拦截函数。
同样，在set拦截函数内，我们使用Reflect.set(target，key,newVal,receiver)
来完成默认的设置行为，即引擎会调用obj对象部署的[[Set]]
内部方法，根据规范的10.1.9.2节可知[[Set]]内部方法的执行流程，

![avatar](/Vue/images/第152页-34.png)

```text
2.如果 ownDesc 是 undefined,那么
  a.让 parent 的值为0.[[GetPrototypeOf]]()。
  b.如果parent不是null,则
    1.返回?parent.[[Set]](P,V,Receiver);
  C.否则
    1.将ownDesc 设置为{[[Value]]:undefined,[[Writable]]:true, [[Enumerable]: true, [[Configurable]]:true }
```

由第2步可知，如果设置的属性不存在于对象上，那么会取得其原型，并调用原型的[[Set]方法，也就是parent的[[Set]]
内部方法。由于parent是代理对象，所以这就相当于执行了它的set拦截函数。
换句话说，虽然我们操作的是child.bar，但这也会导致parent代理对象的set拦截函数被执行。
前面我们分析过，当读取child.bar的值时，副作用函数不仅会被child.bar收集，也会被parent.bar收集。
所以当parent代理对象的set拦截函数执行时，就会触发副作用函数重新执行，这就是为什么修改child.bar的值会导致副作用函数重新执行两次。

接下来，我们需要思考解决方案。思路很简单，既然执行两次，那么只要屏蔽其中一次不就可以了吗?我们可以把由parent.bar触发的那次副作用函数的重新执行屏蔽。
怎么屏蔽呢?我们知道，两次更新是由于set拦截函数被触发了两次导致的，所以只要我们能够在set拦截函数内区分这两次更新就可以了。当我们设置child.bar的值时，会执行child代理对象的set拦截数:

```javascript
// child的set拦截函数
set(target, key, value, receiver)
{
    // target 是原始对象obj
    // receiver 是代理对象child
}
```

此时的target是原始对象obj,recetiver是代理对象child,我们发现receiver 其实就是 target 的代理对象

但由于obj上不存在bar 属性,所以会取得obj的原型parent,并执行parent代理对象的 set拦截函数:

```javascript
// parent的set拦截函数
set(target, key, value, receiver)
{
    // target 是原始对象proto
    // receiver 是代理对象child
}
```

我们发现，当parent代理对象的 set拦截函数执行时，此时 target是始对象proto，而receiver 仍然是代理对象 chtld，而不再是
target的代理对象。通过这个特点，我们可以看到target和receiver的区别。由于我们最初设置的是chtld.bar的值，所以无论在什么情况下,receiver都是child、而
target则是变化的。
根据这个区别，我们很容易想到解决办法，只需要判断receiver是否是target的代理对象即可。只有当receiver是target的代理对象时才触发更新，这样就能够屏蔽由原型引起的更新了。

所以接下来的问题变成了如何确定receiver 是不是target 的代理对象，这需要我们为get拦截函数添加一个能力，如以下代码所示:

```javascript
function reactive(obj) {
    return new Proxy(obj, {
        get(target, key, receiver) {
            if (key === 'raw') {
                return target
            }
            track(target, key)
            return Reflect.get(target, key, receiver)
        }
    })
}
```

我们增加了一段代码，它实现的功能是，代理对象可以通过raw属性读取原始数据，例如:

```javascript
child.raw === obj // true
parent.raw === proto // true
```

有了它，我们就能够在set拦截函数中判断receiver 是不是target的代理对象了:

```javascript
function reactive(obj) {
    return new Proxy(obj, {
        set(target, key, newValue, receiver) {
            const oldValue = target[key]
            const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
            const res = Reflect.set(target, key, newValue, receiver)

            // target === receiver.raw 说明 receiver 就是 target 的代理对象
            if (target === receiver.raw) {
                if (oldValue !== newValue && (oldValue === oldValue || newValue === newValue)) {
                    trigger(target, key, type)
                }
            }
            return res
        }
    })
}
```

如以上代码所示，我们新增了一个判断条件，只有当receiver是target的代理对象时才触发更新，这样就能屏蔽由原型引起的更新，从而避免不必要的更新操作。

## 浅响应与深响应

本节中我们将介绍reactive与shallowReactive的区别,即深响应和浅响应的区别。实际上我们目前所实现的reactive是浅响应的。拿如下代码来说:

```javascript
const obj = reactive({foo: {bar: 1}})

effect(() => {
    console.log(obj.foo.bar)
})

// 修改obj.foo.bar 的值，并不能触发响应
obj.foo.bar = 2
```

首先，创建obj代理对象，该对象的foo属性值也是一个对象，即{bar:1}。接着，在副作用函数内访问obj.foo.bar的值。但是我们发现，后续对obj.foo.bar
的修改不能触发副作用函数重新执行，这是为什么呢?来看一下现在的实现:

```javascript
function reactive(obj) {
    return new Proxy(obj, {
        get(target, key, receiver) {
            if (key === 'raw') {
                return target
            }
            track(target, key)
            return Reflect.get(target, key, receiver)
        }
    })
}
```

由上面这段代码可知，当我们读取obj.foo.bar时，首先要读取obj.foo的值。这里我们直接使用Reflect.get函数返回obj.foo的结果。
由于通过Reflect.get得到obj.foo的结果是一个普通对象，即{bar:
1},它并不是一个响应式对象，所以在副作用函数中访问obj.foo.bar时，是不能建立响应联系的。要解决这个问题，我们需要对Reflect.get返回的结果做一层包装:

```javascript
function reactive(obj) {
    return new Proxy(obj, {
        get(target, key, receiver) {
            if (key === 'raw') {
                return target
            }
            track(target, key)
            // 得到原始值结果
            const res = Reflect.get(target, key, receiver)
            if (typeof res === 'object' && res !== null) {
                return reactive(res)
            }
            return res
        }
    })
}
```

如上面的代码所示，当读取属性值时，我们首先检测该值是否是对象，如果是对象，则递归地调用reactive函数将其包装成响应式数据并返回。
这样当使用obj.foo读取foo属性值时，得到的就会是一个响应式数据，因此再通过obj.foo.bar读取bar属性值时，自然就会建立响应联系。
这样，当修改obj.foo.bar的值时，就能够触发副作用函数重新执行了。
然而，并非所有情况下我们都希望深响应，这就催生了shallowReactive，即浅响应。所谓浅响应，指的是只有对象的第一层属性是响应的，例如:

```javascript
const obj = shallowReactive({foo: {bar: 1}})

effect(() => {
    console.log(obj.foo.bar)
})

// obj.foo 是响应的，可以触发副作用函数重新执行
obj.foo = {bar: 2}
// obj.foo.bar 不是响应的，不能触发副作用函数重新执行
obj.foo.bar = 3
```

在这个例子中，我们使用shallowReactive函数创建了一个浅响应的代理对象obj。可以发现，只有对象的第一层属性是响应的，第二层及更深层次的属性则不是响应的。实现此功能并不难，如下面的代码所示:

```javascript
// 封装createReacttve函数,接状一个参数tsShallow,代表是否为浅响应、默认为false、即非浅响应
function createReactive(obj, isShallow = false) {
    return new Proxy(obj, {
        //拦截读取操作
        get(target, key, receiver) {
            if (key === 'raw') {
                return target
            }
            const res = Reflect.get(target, key, receiver)
            // 如果是浅响应,则直接返回原始值
            if (isShallow) {
                return res
            }
            track(target, key)
            if (typeof res === 'object' && res !== null) {
                return reactive(res)
            }
            return res
        }
    })
}
```

在上面这段代码中，我们把对象创建的工作封装到一个新的函数createReactive 中。该函数除了接收原始对象obj之外，还接收参数
isShallow，它是一个布尔值，代表是否创建浅响应对象。
默认情况下，isShallow的值为false，代表创建深响应对象。这里需要注意的是，当读取属性操作发生时，在get拦截函数内如果发现是浅响应的，那么直接返回原始数据即可。
有了createReactive函数后,我们就可以使用它轻松地实现reactive以及shallowReactive函数了:

```javascript
function reactive(obj) {
    return createReactive(obj)
}

function shallowReactive(obj) {
    return createReactive(obj, true)
}
```

## 只读和浅只读

我们希望一些数据是只读的，当用户尝试修改只读数据时，会收到一条警告信息。这样就实现了对数据的保护，例如组件接收到的props
对象应该是一个只读数据。这时就要用到接下来要讨论的readonly函数，它能够将一个数据变成只读的:

```javascript
const obj = readonly({foo: 1})
// 尝试修改数据,会得到警告
obj.foo = 2
```

只读本质上也是对数据对象的代理，我们同样可以使用createReactive函数来实现。如下面的代码所示，我们为createReactive函数增加第三个参数isReadonly:

```javascript
// 增加第三个参数isReadonly,代表是否只读，默认为false，即非只读
function createReactive(obj, isShallow = false, isReadonly = false) {
    return new Proxy(obj, {
        // 拦截设置操作
        set(target, key, newValue, receiver) {
            // 如果是只读的，则打印警告信息并返回
            if (isReadonly) {
                console.warn(`属性 $[key] 是只读的'`)
                return true
            }
            const oldValue = target[key]
            const type = Object.prototype.hasOwnProperty.call(target, key) ? 'SET' : 'ADD'
            const res = Reflect.set(target, key, newValue, receiver)
            if (target === receiver.raw) {
                if (oldValue !== newValue && (oldValue === oldValue || newValue === newValue)) {
                    trigger(target, key, type)
                }
            }
            return res
        },
        deleteProperty(target, key) {
            // 如果是只读的、则打印警告信息并返回
            if (isReadonly) {
                console.warn(`属性 $[key] 是只读的'`)
                return true
            }
            const hadKey = Object.prototype.hasownproperty.call(target, key)
            const res = Reflect.deleteProperty(target, key)
            if (res && hadkey) {
                trigger(target, key, 'DELETE')
            }
            return res
        }
    })
}
```

在这段代码中，当使用createReactive创建代理对象时，可以通过第三个参数指定是否创建一个只读的代理对象。
同时，我们还修改了get拦截函数和deleteProperty拦截函数的实现、因为对于一个对象来说，只读意味着既不可以设置对象的属性值，也不可以删除对象的属性。
在这两个拦截函数中，我们分别添加了是否是只读的判断，一旦数据是只读的，则当这些操作发生 时，会打印警告信息，提示用户这是一个非法操作。
当然，如果一个数据是只读的，那就意味着任何方式都无法修改它。因此，没有必要为只读数据建立响应联系。
出于这个原因，当在副作用函数中读取一个只读属性的值时，不需要调用track函数追踪响应:

```javascript
const obj = readonly({foo: 1})
effect(() => {
    obj.foo//可以读取值，但是不需委在副作用函数与数据之间建立响应联系
})
```

为了实现该功能，我们需要修改get拦截函数的实现:

```javascript
function createReactive(obj, isShallow = false, isReadonly = false) {
    return new Proxy(obj, {
        // 拦截读取操作
        get(target, key, receiver) {
            if (key === 'raw') {
                return target
            }
            // 非只读的时候才需要建立响应联系
            if (!isReadonly) {
                track(target, key)
            }
            const res = Reflect.get(target, key, receiver)

            if (isShallow) {
                return res
            }

            if (typeof res === 'object' & res !== null) {
                return reactive(res)
            }

            return res
        }
    })
}
```

如上面的代码所示，在get拦截函数内检测isReadonly变量的值，判断是否是只读的，只有在非只读的情况下才会调用track函数建立响应联系。基于此，我们就可以实现readonly函数了:

```javascript
function readonly(obj) {
    return createReactive(obj, false, true /* 只读 */)
}
```

然而,上面实现的readonly函数更应该叫作shallowReadonly，因为它没有做到深只读:

```javascript
const obj = readonly({foo: {bar: 1}})
obj.foo.bar = 2 // 可以修改
```

所以为了实现深只读，我们还应该在get拦截函数内递归地调用readonly将数据包装成只读的代理对象，并将其作为返回值返回:

```javascript
function createReactive(obj, isShallow = false, isReadanly = false) {
    return new Proxy(obj, {
        get(target, key, receiver) {
            if (key === 'raw') {
                return target
            }
            if (!isReadanly) {
                track(target, key)
            }
            const res = Reflect.get(target, key, receiver)

            if (isShallow) {
                return res
            }

            if (typeof res === 'object' && res !== null) {
                // 如果数据为只读，则调用readonly对值进行包装
                return isReadanly ? readonly(res) : reactive(res)
            }
            return res
        }
    })
}
```

如上面的代码所示，我们在返回属性值之前，判断它是否是只读的，如果是只读的，则调用readonly函数对值进行包装，并把包装后的只读对象返回。
对于shallowReadonly，实际上我们只需要修改createReactive的第二个参数即可:

```javascript
function readonly(obj){
    return createReactive(obj, false, true)
}

function shallowReadonly(obj){
    return createReactive(obj,true,true)
}
```

如上面的代码所示，在shallowReadonly函数内调用createReactive函数创建代理对象时，第二个参数isShallow设置为true，这样就可以创建一个浅只读的代理对象了

## 代理数组

从本节开始，我们讲解如何代理数组。实际上，在JavaScrpt中，数组只是一个特殊的对象而已，因此想要更好地实现对数组的代理，就有必要了解相比普通对象，数组到底有何特殊之处。
在5.2节中，我们深人讲解了JavaScript中的对象。我们知道，在JavaScript中有两种对象:常规对象和异质对象。我们还讨论了两者的差异。
而本节中我们要介绍的数组就是一个异质对象，这是因为数组对象的[[DefineOwnProperty]]内部方法与常规对象不同。
换句话说，数组对象除了[[DefineownProperty]]这个内部方法之外，其他内部方法的逻辑都与常规对象相同。因此，当实现对数组的代理时，用于代理普通对象的大部分代码可以继续使用，如下所示:

```javascript
const arr = reactive(['foo'])

effect(()=>{
    console.log(arr[0])
})

arr[0] = 'bar' // 触发响应
```
