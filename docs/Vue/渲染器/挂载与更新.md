# 挂载与更新

在第上一章中，我们主要介绍了渲染器的基本概念和整体架构。本章，我们将讲解渲染器的核心功能：挂载与更新。

## 挂载子节点和元素的属性

第上一章提到，当 vnode.children 的值是字符串类型时，会把它设置为元素的文本内容。
一个元素除了具有文本子节点外，还可以包含其他元素子节点，并且子节点可以是很多个。
为了描述元素的子节点，我们需要将 vnode.children 定义为数组：

```javascript
01 const vnode = {
02 type: 'div',
03 children: [
04 {
05 type: 'p',
06 children: 'hello'
07 }
08 ]
09 }
```

上面这段代码描述的是“一个 div 标签具有一个子节点，且子节点
是 p 标签”。可以看到，vnode.children 是一个数组，它的每一个
元素都是一个独立的虚拟节点对象。这样就形成了树型结构，即虚拟
DOM 树。

为了完成子节点的渲染，我们需要修改 mountElement 函数，如
下面的代码所示：

```javascript
01 function mountElement(vnode, container) {
02 const el = createElement(vnode.type)
03 if (typeof vnode.children === 'string') {
04 setElementText(el, vnode.children)
05 } else if (Array.isArray(vnode.children)) {
06 // 如果 children 是数组，则遍历每一个子节点，并调用 patch 函数挂载它们
07 vnode.children.forEach(child => {
08 patch(null, child, el)
09 })
10 }
11 insert(el, container)
12 }
```

在上面这段代码中，我们增加了新的判断分支。使用Array.isArray 函数判断 vnode.children 是否是数组，如果是数组，则循环遍历它，并调 patch 函数挂载数组中的虚拟节点。在挂载子节点时，需要注意以下两点。

- 传递给 patch 函数的第一个参数是 null。因为是挂载阶段，没有旧 vnode，所以只需要传递 null 即可。这样，当 patch 函数执行时，就会递归地调用 mountElement 函数完成挂载。
- 传递给 patch 函数的第三个参数是挂载点。由于我们正在挂载的子元素是 div 标签的子节点，所以需要把刚刚创建的 div 元素作为挂载点，这样才能保证这些子节点挂载到正确位置。

完成了子节点的挂载后，我们再来看看如何用 vnode 描述一个标签的属性，以及如何渲染这些属性。
我们知道，HTML 标签有很多属性，其中有些属性是通用的，例如 id、class 等，而有些属性是特定元素才有的，例如 form 元素的 action 属性。
实际上，渲染一个元素的属性比想象中要复杂，不过我们仍然秉承一切从简的原则，先来看看最基本的属性处理。

为了描述元素的属性，我们需要为虚拟 DOM 定义新的vnode.props 字段，如下面的代码所示：

```javascript
01 const vnode = {
02 type: 'div',
03 // 使用 props 描述一个元素的属性
04 props: {
05 id: 'foo'
06 },
07 children: [
08 {
09 type: 'p',
10 children: 'hello'
11 }
12 ]
13 }
```

vnode.props 是一个对象，它的键代表元素的属性名称，它的值代表对应属性的值。这样，我们就可以通过遍历 props 对象的方式，把这些属性渲染到对应的元素上，如下面的代码所示：

```javascript
01 function mountElement(vnode, container) {
02 const el = createElement(vnode.type)
03 // 省略 children 的处理
04
05 // 如果 vnode.props 存在才处理它
06 if (vnode.props) {
07 // 遍历 vnode.props
08 for (const key in vnode.props) {
09 // 调用 setAttribute 将属性设置到元素上
10 el.setAttribute(key, vnode.props[key])
11 }
12 }
13
14 insert(el, container)
15 }
```

在这段代码中，我们首先检查了 vnode.props 字段是否存在，如果存在则遍历它，并调用 setAttribute 函数将属性设置到元素上。
实际上，除了使用 setAttribute 函数为元素设置属性之外，还可以通过 DOM 对象直接设置：

```javascript
01 function mountElement(vnode, container) {
02 const el = createElement(vnode.type)
03 // 省略 children 的处理
04
05 if (vnode.props) {
06 for (const key in vnode.props) {
07 // 直接设置
08 el[key] = vnode.props[key]
09 }
10 }
11
12 insert(el, container)
13 }
```

在这段代码中，我们没有选择使用 setAttribute 函数，而是直接将属性设置在 DOM 对象上，即 el[key] =vnode.props[key]。
实际上，无论是使用 setAttribute 函数，还是直接操作 DOM 对象，都存在缺陷。如前所述，为元素设置属性比想象中要复杂得多。
不过，在讨论具体有哪些缺陷之前，我们有必要先搞清楚两个重要的概念：HTML Attributes 和 DOM Properties。

## HTML Attributes 与 DOM Properties

理解 HTML Attributes 和 DOM Properties 之间的差异和关联非常重要，这能够帮助我们合理地设计虚拟节点的结构，更是正确地为元素设置属性的关键。

我们从最基本的 HTML 说起。给出如下 HTML 代码：

```html
 <input id="my-input" type="text" value="foo" />
```

HTML Attributes 指的就是定义在 HTML 标签上的属性，这里指的就是 id="my-input"、type="text" 和 value="foo"。
当浏览器解析这段 HTML 代码后，会创建一个与之相符的 DOM 元素对象，我们可以通过 JavaScript 代码来读取该 DOM 对象：

```javascript
const el = document.querySelector('#my-input')
```

这个 DOM 对象会包含很多属性（properties）,如图所示:

![avatar](/Vue/images/第254页-42.png)

这些属性就是所谓的 DOM Properties。很多 HTML Attributes 在 DOM 对象上有与之同名的 DOM Properties，例如 id="my-input" 对应 el.id，type="text" 对应 el.type，value="foo" 对应el.value 等。
但 DOM Properties 与 HTML Attributes 的名字不总是一模一样的，例如：

```html
<div class="foo"></div
```

class="foo" 对应的 DOM Properties 则是 el.className。另外，并不是所有 HTML Attributes 都有与之对应的 DOM Properties，例如：

```html
<div aria-valuenow="75"></div
```

aria-* 类的 HTML Attributes 就没有与之对应的 DOM Properties。

类似地，也不是所有 DOM Properties 都有与之对应的 HTML Attributes，例如可以用 el.textContent 来设置元素的文本内容，但并没有与之对应的 HTML Attributes 来完成同样的工作。

HTML Attributes 的值与 DOM Properties 的值之间是有关联的，例如下面的 HTML 片段：

```html
 <div id="foo"></div>
```

这个片段描述了一个具有 id 属性的 div 标签。其中，id="foo"对应的 DOM Properties 是 el.id，并且值为字符串 'foo'。
我们把这种 HTML Attributes 与 DOM Properties 具有相同名称（即 id）的属性看作直接映射。
但并不是所有 HTML Attributes 与 DOM Properties 之间都是直接映射的关系，例如：

```html
 <input value="foo" />
```

这是一个具有 value 属性的 input 标签。如果用户没有修改文本框的内容，那么通过 el.value 读取对应的 DOM Properties 的值就是字符串 'foo'。
而如果用户修改了文本框的值，那么 el.value 的值就是当前文本框的值。例如，用户将文本框的内容修改为 'bar'，那么：

```javascript
console.log(el.value) // 'bar'
```

但如果运行下面的代码，会发生“奇怪”的现象：

```javascript
01 console.log(el.getAttribute('value')) // 仍然是 'foo'
02 console.log(el.value) // 'bar'
```

可以发现，用户对文本框内容的修改并不会影响el.getAttribute('value') 的返回值，这个现象蕴含着 HTML Attributes 所代表的意义。
实际上，HTML Attributes 的作用是设置与之对应的 DOM Properties 的初始值。
一旦值改变，那么 DOM Properties始终存储着当前值，而通过 getAttribute 函数得到的仍然是初始值。

但我们仍然可以通过 el.defaultValue 来访问初始值，如下面的代码所示：

```javascript
01 el.getAttribute('value') // 仍然是 'foo'
02 el.value // 'bar'
03 el.defaultValue // 'foo'
```

这说明一个 HTML Attributes 可能关联多个 DOM Properties。例如在上例中，value="foo" 与 el.value 和 el.defaultValue 都有关联。

虽然我们可以认为 HTML Attributes 是用来设置与之对应的 DOM Properties 的初始值的，但有些值是受限制的，就好像浏览器内部做了默认值校验。
如果你通过 HTML Attributes 提供的默认值不合法，那么浏览器会使用内建的合法值作为对应 DOM Properties 的默认值，例如：

```html
<input type="foo" />
```

我们知道，为 `<input/>` 标签的 type 属性指定字符串 'foo' 是不合法的，因此浏览器会矫正这个不合法的值。所以当我们尝试读取el.type 时，得到的其实是矫正后的值，即字符串 'text'，而非字符串 'foo'：

```javascript
 console.log(el.type) // 'text'
```

从上述分析来看，HTML Attributes 与 DOM Properties 之间的关系很复杂，但其实我们只需要记住一个核心原则即可：HTML Attributes的作用是设置与之对应的 DOM Properties 的初始值。

## 正确地设置元素属性

上一节我们详细讨论了 HTML Attributes 和 DOM Properties 相关的内容，因为 HTML Attributes 和 DOM Properties 会影响 DOM 属性的添加方式。
对于普通的 HTML 文件来说，当浏览器解析 HTML 代码后，会自动分析 HTML Attributes 并设置合适的 DOM Properties。
但用户编写在 Vue.js 的单文件组件中的模板不会被浏览器解析，这意味着，原本需要浏览器来完成的工作，现在需要框架来完成。

我们以禁用的按钮为例，如下面的 HTML 代码所示：

```html
<button disabled>Button</button>
```

浏览器在解析这段 HTML 代码时，发现这个按钮存在一个叫作disabled 的 HTML Attributes，于是浏览器会将该按钮设置为禁用状态，并将它的 el.disabled 这个 DOM Properties 的值设置为true，这一切都是浏览器帮我们处理好的。
但同样的代码如果出现在Vue.js 的模板中，则情况会有所不同。首先，这个 HTML 模板会被编译成 vnode，它等价于：

```javascript
01 const button = {
02 type: 'button',
03 props: {
04 disabled: ''
05 }
06 }
```

注意，这里的 props.disabled 的值是空字符串，如果在渲染器中调用 setAttribute 函数设置属性，则相当于：

```javascript
el.setAttribute('disabled', '')
```

这么做的确没问题，浏览器会将按钮禁用。但考虑如下模板：

```html
<button :disabled="false">Button</button>
```

它对应的 vnode 为：

```javascript
01 const button = {
02 type: 'button',
03 props: {
04 disabled: false
05 }
06 }
```

用户的本意是“不禁用”按钮，但如果渲染器仍然使用setAttribute 函数设置属性值，则会产生意外的效果，即按钮被禁用了：

```javascript
 el.setAttribute('disabled', false)
```

在浏览器中运行上面这句代码，我们发现浏览器仍然将按钮禁用了。这是因为使用 setAttribute 函数设置的值总是会被字符串化，所以上面这句代码等价于：

```javascript
el.setAttribute('disabled', 'false')
```

对于按钮来说，它的 el.disabled 属性值是布尔类型的，并且它不关心具体的 HTML Attributes 的值是什么，只要 disabled 属性存在，按钮就会被禁用。
所以我们发现，渲染器不应该总是使用setAttribute 函数将 vnode.props 对象中的属性设置到元素上。那么应该怎么办呢？一个很自然的思路是，我们可以优先设置 DOM Properties，例如：

```javascript
el.disabled = false
```

这样是可以正确工作的，但又带来了新的问题。还是以上面给出的模板为例：

```html
<button disabled>Button</button>
```

这段模板对应的 vnode 是：

```javascript
01 const button = {
02 type: 'button',
03 props: {
04 disabled: ''
05 }
06 }
```

我们注意到，在模板经过编译后得到的 vnode 对象中，props.disabled 的值是一个空字符串。如果直接用它设置元素的DOM Properties，那么相当于：

```javascript
el.disabled = ''
```

由于 el.disabled 是布尔类型的值，所以当我们尝试将它设置为空字符串时，浏览器会将它的值矫正为布尔类型的值，即 false。所以上面这句代码的执行结果等价于：

```javascript
el.disabled = false
```

这违背了用户的本意，因为用户希望禁用按钮，而 el.disabled = false 则是不禁用的意思。

这么看来，无论是使用 setAttribute 函数，还是直接设置元素的 DOM Properties，都存在缺陷。
要彻底解决这个问题，我们只能做特殊处理，即优先设置元素的 DOM Properties，但当值为空字符串时，要手动将值矫正为 true。
只有这样，才能保证代码的行为符合预期。下面的 mountElement 函数给出了具体的实现：

```javascript
01 function mountElement(vnode, container) {
02 const el = createElement(vnode.type)
03 // 省略 children 的处理
04
05 if (vnode.props) {
06 for (const key in vnode.props) {
07 // 用 in 操作符判断 key 是否存在对应的 DOM Properties
08 if (key in el) {
09 // 获取该 DOM Properties 的类型
10 const type = typeof el[key]
11 const value = vnode.props[key]
12 // 如果是布尔类型，并且 value 是空字符串，则将值矫正为 true
13 if (type === 'boolean' && value === '') {
14 el[key] = true
15 } else {
16 el[key] = value
17 }
18 } else {
19 // 如果要设置的属性没有对应的 DOM Properties，则使用setAttribute 函数设置属性
20 el.setAttribute(key, vnode.props[key])
21 }
22 }
23 }
24
25 insert(el, container)
26 }
```

如上面的代码所示，我们检查每一个 vnode.props 中的属性，看看是否存在对应的 DOM Properties，如果存在，则优先设置 DOMProperties。
同时，我们对布尔类型的 DOM Properties 做了值的矫正，即当要设置的值为空字符串时，将其矫正为布尔值 true。
当然，如果vnode.props 中的属性不具有对应的 DOM Properties，则仍然使用setAttribute 函数完成属性的设置。

但上面给出的实现仍然存在问题，因为有一些 DOM Properties 是只读的，如以下代码所示：

```html
<form id="form1"></form>
<input form="form1" />
```

在这段代码中，我们为 `<input/>` 标签设置了 form 属性（HTML Attributes）。
它对应的 DOM Properties 是 el.form，但el.form 是只读的，因此我们只能够通过 setAttribute 函数来设置它。这就需要我们修改现有的逻辑：

```javascript
01 function shouldSetAsProps(el, key, value) {
02 // 特殊处理
03 if (key === 'form' && el.tagName === 'INPUT') return false
04 // 兜底
05 return key in el
06 }
07
08 function mountElement(vnode, container) {
09 const el = createElement(vnode.type)
10 // 省略 children 的处理
11
12 if (vnode.props) {
13 for (const key in vnode.props) {
14 const value = vnode.props[key]
15 // 使用 shouldSetAsProps 函数判断是否应该作为 DOM Properties设置
16 if (shouldSetAsProps(el, key, value)) {
17 const type = typeof el[key]
18 if (type === 'boolean' && value === '') {
19 el[key] = true
20 } else {
21 el[key] = value
22 }
23 } else {
24 el.setAttribute(key, value)
25 }
26 }
27 }
28
29 insert(el, container)
30 }
```

如上面的代码所示，为了代码的可读性，我们提取了一个shouldSetAsProps 函数。
该函数会返回一个布尔值，代表属性是否应该作为 DOM Properties 被设置。
如果返回 true，则代表应该作为DOM Properties 被设置，否则应该使用 setAttribute 函数来设置。
在 shouldSetAsProps 函数内，我们对 `<input form="xxx" />`进行特殊处理，即 `<input/>` 标签的 form 属性必须使用setAttribute 函数来设置。
实际上，不仅仅是 `<input/>` 标签，所有表单元素都具有 form 属性，它们都应该作为 HTML Attributes 被设置。

当然，`<input form="xxx"/>` 是一个特殊的例子，还有一些其他类似于这种需要特殊处理的情况。
我们不会列举所有情况并一一讲解，因为掌握处理问题的思路更加重要。
另外，我们也不可能把所有需要特殊处理的地方都记住，更何况有时我们根本不知道在什么情况下才需要特殊处理。
所以，上述解决方案本质上是经验之谈。不要惧怕写出不完美的代码，只要在后续迭代过程中“见招拆招“，代码就会变得越来越完善，框架也会变得越来越健壮。

最后，我们需要把属性的设置也变成与平台无关，因此需要把属性设置相关操作也提取到渲染器选项中，如下面的代码所示：

```javascript
01 const renderer = createRenderer({
02 createElement(tag) {
03 return document.createElement(tag)
04 },
05 setElementText(el, text) {
06 el.textContent = text
07 },
08 insert(el, parent, anchor = null) {
09 parent.insertBefore(el, anchor)
10 },
11 // 将属性设置相关操作封装到 patchProps 函数中，并作为渲染器选项传递
12 patchProps(el, key, prevValue, nextValue) {
13 if (shouldSetAsProps(el, key, nextValue)) {
14 const type = typeof el[key]
15 if (type === 'boolean' && nextValue === '') {
16 el[key] = true
17 } else {
18 el[key] = nextValue
19 }
20 } else {
21 el.setAttribute(key, nextValue)
22 }
23 }
24 })
```

而在 mountElement 函数中，只需要调用 patchProps 函数，并为其传递相关参数即可：

```javascript
01 function mountElement(vnode, container) {
02 const el = createElement(vnode.type)
03 if (typeof vnode.children === 'string') {
04 setElementText(el, vnode.children)
05 } else if (Array.isArray(vnode.children)) {
06 vnode.children.forEach(child => {
07 patch(null, child, el)
08 })
09 }
10
11 if (vnode.props) {
12 for (const key in vnode.props) {
13 // 调用 patchProps 函数即可
14 patchProps(el, key, null, vnode.props[key])
15 }
16 }
17
18 insert(el, container)
19 }
```

这样，我们就把属性相关的渲染逻辑从渲染器的核心中抽离了出来。

## class 的处理

在上一节中，我们讲解了如何正确地把 vnode.props 中定义的属性设置到 DOM 元素上。
但在 Vue.js 中，仍然有一些属性需要特殊处理，比如 class 属性。为什么需要对 class 属性进行特殊处理呢？
这是因为 Vue.js 对 calss 属性做了增强。在 Vue.js 中为元素设置类名有以下几种方式。

方式一：指定 class 为一个字符串值。

```html
<p class="foo bar"></p>
```

这段模板对应的 vnode 是：

```javascript
01 const vnode = {
02 type: 'p',
03 props: {
04 class: 'foo bar'
05 }
06 }
```

方式二：指定 class 为一个对象值。

```html
<p :class="cls"></p>
```

假设对象 cls 的内容如下：

```javascript
const cls = { foo: true, bar: false }
```

那么，这段模板对应的 vnode 是：

```javascript
01 const vnode = {
02 type: 'p',
03 props: {
04 class: { foo: true, bar: false }
05 }
06 }
```

方式三：class 是包含上述两种类型的数组。

```html
<p :class="arr"></p>
```

这个数组可以是字符串值与对象值的组合：

```javascript
01 const arr = [
02 // 字符串
03 'foo bar',
04 // 对象
05 {
06 baz: true
07 }
08 ]
```

那么，这段模板对应的 vnode 是：

```javascript
01 const vnode = {
02 type: 'p',
03 props: {
04 class: [
05 'foo bar',
06 { baz: true }
07 ]
08 }
09 }
```

可以看到，因为 class 的值可以是多种类型，所以我们必须在设置元素的 class 之前将值归一化为统一的字符串形式，再把该字符串作为元素的 class 值去设置。
因此，我们需要封装normalizeClass 函数，用它来将不同类型的 class 值正常化为字符串，例如：

```javascript
01 const vnode = {
02 type: 'p',
03 props: {
04 // 使用 normalizeClass 函数对值进行序列化
05 class: normalizeClass([
06 'foo bar',
07 { baz: true }
08 ])
09 }
10 }
```

最后的结果等价于：

```javascript
01 const vnode = {
02 type: 'p',
03 props: {
04 // 序列化后的结果
05 class: 'foo bar baz'
06 }
07 }
```

至于 normalizeClass 函数的实现，这里我们不会做详细讲解，因为它本质上就是一个数据结构转换的小算法，实现起来并不复杂。

假设现在我们已经能够对 class 值进行正常化了。
接下来，我们将讨论如何将正常化后的 class 值设置到元素上。
其实，我们目前实现的渲染器已经能够完成 class 的渲染了。
观察前文中函数的代码，由于 class 属性对应的 DOM Properties 是 el.className，所以表达式 'class' in el 的值将会是 false，因此，patchProps 函数会使用 setAttribute 函数来完成 class 的设置。
但是我们知道，在浏览器中为一个元素设置 class 有三种方式，即使用setAttribute、el.className 或 el.classList。
那么哪一种方法的性能更好呢？下图对比了这三种方式为元素设置 1000 次 class 的性能。

![avatar](/Vue/images/第266页-43.png)

可以看到，el.className 的性能最优。因此，我们需要调整patchProps 函数的实现，如下面的代码所示：