# 浏览器

## 浏览器渲染流程

### 渲染流程

![avatar](/images/渲染流程.png)

1. HTML 解析构建 DOM 树
   浏览器无法识别 html 文件，需要将 html 解析成 DOM 树，解析过程是一个深度遍历的过程，只有当某个节点下所有子节点都遍历完成了才会去解析下一个兄弟节点。在这个阶段

2. CSS 解析
   和 HTML 的解析过程同步执行，浏览器将识别所有的 CSS 样式信息，并构建形成 `CSSOM(css对象模型)` 树。CSSOM 树大致如下：

![avatar](/images/渲染流程解析css.png)

- HTML、CSS 的解析过程可能会被 JS 引擎线程所阻塞。
- 样式为不可见的一些树节点（display:none）也会被构建进树结构中，只有在后面的 render 树会做过滤。

3. 样式与结构合并
   CSSOM 树和 DOM 树合并，形成 `Render树(渲染树)`。形成 Render 树的过程中，浏览器会筛选出所有可见的节点（visibility: hidden 的元素在 Render Tree 中），针对可见节点匹配其 CSSOM 树种的 CSS 规则。

4. 布局阶段
   布局阶段主要是将渲染树遍历，将`元素嵌套关系`以`盒子模型`的形式写入文档流。这个阶段会计算出每个树节点应该占据的空间以及在视图中的位置，一些布局的样式如 `float`、`absolute`、`fixed` 造成的偏移就会在这个阶段生效。

5. 绘制阶段这个阶段会将我们的渲染树转化为像素，并对所有的媒体文件进行解码。

### 回流和重绘

在页面初次加载完毕之后，我们可能由于交互或者一些 JS 操作，导致页面的布局和样式发生变化，从而重新触发浏览器的渲染过程，这期间就会涉及到回流和重绘两种情况。

1. **回流**<br>

当我们的操作引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是重排（也叫回流）。

![image](/images/渲染流程回流.png)

触发回流的情况：
a.改变 DOM 树的结构，如移动、删除、增加节点、修改节点尺寸等操作
b.获取一些特定属性的值，如 `offsetTop`、`offsetLeft`、 `offsetWidth`、`offsetHeight`、`scrollTop`、`scrollLeft`、`scrollWidth`、`scrollHeight`、`clientTop`、`clientLeft`、`clientWidth`、`clientHeight` 等，这些属性都是需要通过`实时计算`得到的，浏览器为了获取他们的值，也会触发回流。
c.手动调用 `getComputedStyle` 方法等，也会触发浏览器的实时计算，同样也触发回流。

2. **重绘**<br>

当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。
![image](/images/渲染流程重绘.png)

3. **如何减少回流和重绘**<br>

可以将要多次修改的 DOM 元素设置 display:none，因为 display:none 的元素不会被包含在 renderTree 中，当修改完之后，在设置为 display:block 这样就只会触发一次回流操作。尽可能避免读取会触发回流的 css 属性使用 transform 做形变和位移可以减少 reflow 采用绝对定位将一些复杂的元素脱离文档流，形成新的 RenderLayer，降低回流成本。

## 浏览器缓存机制

- 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；
- 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持 HTTP1.1，则使用 expires 头判断是否过期；
- 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；
- 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；
- 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；

![avatar](/images/浏览器缓存.png)
很多网站的资源后面都加了`版本号`，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。

## 协商缓存和强缓存

### 强缓存

使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求，强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 `Expires` 属性和 `Cache-Control` 属性。

1.服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况这样就可能会影响缓存命中的结果。

2.Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值。

- **public**：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用 max-age=来精确控制；
- **private**：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的 HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；
- **no-cache**：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；
- **no-store**：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；
- **max-age=**：设置缓存的最大有效期，单位为秒；
- **s-maxage=**：优先级高于 max-age=，仅适用于共享缓存(CDN)，优先级高于 max-age 或者 Expires 头；
- **max-stale[=]**：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。

一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。

`no-cache` 和 `no-store` 很容易混淆：

- **no-cache**:指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；
- **no-store**:是指不使用任何缓存，每次请求都直接从服务器获取资源。

### 协商缓存

如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。

上面已经说到了，命中协商缓存的条件有两个：

- max-age=xxx 过期了
- 值为 no-cache

使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源，协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 `Etag` 和 `Last-Modified` 属性。

- 服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 `If-Modified-Since` 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。

- 因为 `Last-Modified` 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 `Etag` 属性。服务器在返回资源的时候，在头信息中添加了 `Etag` 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 `If-None-Match` 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 `Etag` 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 `Last-Modified` 的方式更加精确。当 `Last-Modified` 和 `Etag` 属性同时出现的时候，`Etag` 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 `Last-Modified` 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑`负载平衡`时，最好不要设置 Etag 属性。

### 总结

`强缓存策略`和`协商缓存策略`在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。

## 常用浏览器内核

- **IE 浏览器内核**：Trident 内核，也是俗称的 IE 内核；
- **Chrome 浏览器内核**：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink 内核；
- **Firefox 浏览器内核**：Gecko 内核，俗称 Firefox 内核；
- **Safari 浏览器内核**：Webkit 内核；
- **Opera 浏览器内核**：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；
- **360 浏览器、猎豹浏览器内核**：IE + Chrome 双内核；
- **搜狗、遨游、QQ 浏览器内核**：Trident（兼容模式）+ Webkit（高速模式）；
- **百度浏览器、世界之窗内核**：IE 内核；
- **2345 浏览器内核**：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；
- **UC 浏览器内核**：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核
