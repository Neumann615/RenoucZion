# 浏览器

## 浏览器渲染流程

### 渲染流程

![avatar](/images/渲染流程.png)

1. HTML 解析构建 DOM 树
   浏览器无法识别 html 文件，需要将 html 解析成 DOM 树，解析过程是一个深度遍历的过程，只有当某个节点下所有子节点都遍历完成了才会去解析下一个兄弟节点。在这个阶段

2. CSS 解析
   和 HTML 的解析过程同步执行，浏览器将识别所有的 CSS 样式信息，并构建形成 `CSSOM(css对象模型)` 树。CSSOM 树大致如下：

![avatar](/images/渲染流程解析css.png)

- HTML、CSS 的解析过程可能会被 JS 引擎线程所阻塞。
- 样式为不可见的一些树节点（display:none）也会被构建进树结构中，只有在后面的 render 树会做过滤。

3. 样式与结构合并
   CSSOM 树和 DOM 树合并，形成 `Render树(渲染树)`。形成 Render 树的过程中，浏览器会筛选出所有可见的节点（visibility: hidden 的元素在 Render Tree 中），针对可见节点匹配其
   CSSOM 树种的 CSS 规则。

4. 布局阶段
   布局阶段主要是将渲染树遍历，将`元素嵌套关系`以`盒子模型`的形式写入文档流。这个阶段会计算出每个树节点应该占据的空间以及在视图中的位置，一些布局的样式如 `float`、`absolute`、`fixed`
   造成的偏移就会在这个阶段生效。

5. 绘制阶段这个阶段会将我们的渲染树转化为像素，并对所有的媒体文件进行解码。

### 回流和重绘

在页面初次加载完毕之后，我们可能由于交互或者一些 JS 操作，导致页面的布局和样式发生变化，从而重新触发浏览器的渲染过程，这期间就会涉及到回流和重绘两种情况。

1. **回流**<br>

当我们的操作引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是重排（也叫回流）。

![image](/images/渲染流程回流.png)

触发回流的情况：
a.改变 DOM 树的结构，如移动、删除、增加节点、修改节点尺寸等操作
b.获取一些特定属性的值，如 `offsetTop`、`offsetLeft`、 `offsetWidth`、`offsetHeight`、`scrollTop`、`scrollLeft`、`scrollWidth`
、`scrollHeight`、`clientTop`、`clientLeft`、`clientWidth`、`clientHeight` 等，这些属性都是需要通过`实时计算`得到的，浏览器为了获取他们的值，也会触发回流。
c.手动调用 `getComputedStyle` 方法等，也会触发浏览器的实时计算，同样也触发回流。

2. **重绘**<br>

当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。
![image](/images/渲染流程重绘.png)

3. **如何减少回流和重绘**<br>

可以将要多次修改的 DOM 元素设置 display:none，因为 display:none 的元素不会被包含在 renderTree 中，当修改完之后，在设置为 display:block
这样就只会触发一次回流操作。尽可能避免读取会触发回流的 css 属性使用 transform 做形变和位移可以减少 reflow 采用绝对定位将一些复杂的元素脱离文档流，形成新的 RenderLayer，降低回流成本。

## 浏览器缓存机制

- 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；
- 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持
  HTTP1.1，则使用 expires 头判断是否过期；
- 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；
- 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；
- 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；

![avatar](/images/浏览器缓存.png)
很多网站的资源后面都加了`版本号`，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。

## 协商缓存和强缓存

### 强缓存

使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求，强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 `Expires` 属性和 `Cache-Control` 属性。

1.服务器通过在响应头中添加 Expires
属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况这样就可能会影响缓存命中的结果。

2.Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值。

- **public**：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用 max-age=来精确控制；
- **private**：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的 HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；
- **no-cache**：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；
- **no-store**：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；
- **max-age=**：设置缓存的最大有效期，单位为秒；
- **s-maxage=**：优先级高于 max-age=，仅适用于共享缓存(CDN)，优先级高于 max-age 或者 Expires 头；
- **max-stale[=]**：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。

一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。

`no-cache` 和 `no-store` 很容易混淆：

- **no-cache**:指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；
- **no-store**:是指不使用任何缓存，每次请求都直接从服务器获取资源。

### 协商缓存

如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。

上面已经说到了，命中协商缓存的条件有两个：

- max-age=xxx 过期了
- 值为 no-cache

使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源，协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 `Etag`
和 `Last-Modified` 属性。

- 服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 `If-Modified-Since` 的属性，属性值为上一次资源返回时的
  Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304
  状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，那么文件已将改变了但是
  Last-Modified 却没有改变，这样会造成缓存命中的不准确。

- 因为 `Last-Modified` 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 `Etag` 属性。服务器在返回资源的时候，在头信息中添加了 `Etag`
  属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 `If-None-Match` 属性，这个属性的值就是上次返回的资源的 Etag
  的值。服务接收到请求后会根据这个值来和资源当前的 `Etag` 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 `Last-Modified` 的方式更加精确。当 `Last-Modified`
  和 `Etag` 属性同时出现的时候，`Etag` 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 `Last-Modified` 应该保持一致，因为每个服务器上 Etag
  的值都不一样，因此在考虑`负载平衡`时，最好不要设置 Etag 属性。

### 总结

`强缓存策略`和`协商缓存策略`
在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。

## 常用浏览器内核

- **IE 浏览器内核**：Trident 内核，也是俗称的 IE 内核；
- **Chrome 浏览器内核**：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink 内核；
- **Firefox 浏览器内核**：Gecko 内核，俗称 Firefox 内核；
- **Safari 浏览器内核**：Webkit 内核；
- **Opera 浏览器内核**：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；
- **360 浏览器、猎豹浏览器内核**：IE + Chrome 双内核；
- **搜狗、遨游、QQ 浏览器内核**：Trident（兼容模式）+ Webkit（高速模式）；
- **百度浏览器、世界之窗内核**：IE 内核；
- **2345 浏览器内核**：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；
- **UC 浏览器内核**：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核

## 浏览器存储方式

- **cookie:** 在 HTML5 标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带 cookie ⽅便，缺点是⼤⼩只有 `4k`，⾃动请求头加⼊ cookie 浪费流量，每个 domain 限制 20 个
  cookie，使⽤起来麻烦，需要⾃⾏封装。

- **localStorage:** HTML5 加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为 `5M`，兼容 IE8+。

- **sessionStorage:** 与 localStorage 基本类似，区别是 sessionStorage 当⻚⾯关闭后会被清理，⽽且与 cookie、localStorage
  不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式。

- **Web SQL:** 2010 年被 W3C 废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql 类似于 SQLite，是真正意义上的`关系型数据库`，⽤ `sql` 进⾏操作，当我们⽤
  JavaScript 时要进⾏转换，较为繁琐。

- **IndexedDB:** 是被正式纳⼊ HTML5 标准的数据库储存⽅案，它是 `NoSQL` 数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合 web 场景，同时⽤ JavaScript 进⾏操作会⾮常便。

## 浏览器多个标签页之间通信

实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发：

- 使用`websocket`协议,因为 webscoket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发；
- 使用`ShareWorker`的方式，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。
- 使用`localStorage`的方式，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取数据。此时 localStorage
  对象就是充当中介者的角色。
- 使用`postMessage`方法，如果我们能够获得对应标签页的引用，就可以使用 postMessage 方法，进行通信。

## 同源策略

同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互，这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。

同源政策主要限制了三个方面

- 当前域下的 js 脚本不能够访问其他域下的 `cookie`、`localStorage` 和 `indexDB`。
- 当前域下的 js 脚本不能够操作访问操作其他域下的 `DOM`。
- 当前域下 ajax 无法发送`跨域请求`。

同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者 script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。

## 解决跨域

### JSONP

利用标签 script、img、iframe、link 等不存在跨域的限制，但存在局限性，仅支持 get 方法，同时也不安全，可能会遭受 xss 攻击。

### CORS 跨域资源共享

通过服务器设置一些列响应头来实现跨域。

```js
//服务器设置CORS,允许浏览器跨域
res.setHeader("Access-Control-Allow-Origin", "*");
```

### nginx反向代理

通过`代理服务器`接收客户端发送的请求

### postMessage

postMessage是html5引入的API，允许来自`不同源的脚本`采用`异步方式`进行的通信，可以实现跨文本文档，多窗口，跨域消息传递。多用于窗口间数据通信，这也是它成为跨域通信的一种有效的解决方案。

### WebSocket 协议跨域

WebSocket是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯。它最大的特点就是，服务器可以主动向客户端推送消息，客户端也可以主动向服务器发送信息，属于服务器推送技术的一种。

## SEO优化

- 合理的`title`、`description`、`keywords`:
  搜索对着三项的权重逐个减小，title值强调重点即可,重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同;`keywords`
  列举出重要关键词即可。
- 语义化的`HTML`代码，符合W3C规范:语义化代码让搜索引擎容易理解网页
- 重要内容`HTML`代码放在最前:搜索引擎抓取 HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
- 重要内容不要用js 输出:爬虫不会执行js 获取内容.少用`iframe` :搜索引擎不会抓取iframe中的内容
- 非装饰性图片必须加`alt`
- 提高网站速度:`网站速度`是搜索引擎排序的一个重要指标
