# 耻辱柱

## html的语义化标签

HTML的语义化标签指的是那些能够明确表示文档结构和内容语义的HTML元素，它们帮助开发者编写更有意义、更易于阅读和维护的代码，同时也使网页内容更加容易被屏幕阅读器等辅助技术理解，有利于搜索引擎优化（SEO）。以下是一些常用的HTML5语义化标签：

- `<header>`：定义页面或区域的头部信息，通常包含导航、logo、搜索框等元素。

- `<nav>`：表示页面的导航链接部分，用于包裹主要的导航菜单。

- `<main>`：标记文档或应用程序的主要内容，直接与文档主题相关，一个页面中只应有一个`<main>`元素。

- `<article>`：用于定义文档、页面或应用程序中独立的内容，如新闻文章、博客帖子等，可以独立分发和复用。

- `<section>`：定义文档中的一个独立部分或章节，通常包含标题（如`<h1>`-`<h6>`）和其他相关内容。

- `<aside>`：表示和页面主要内容相关但可以独立分开的内容，如侧边栏、注释、引用等。

- `<footer>`：定义页面或区域的底部，通常包含版权信息、联系方式等。

- `<figure>` 和 `<figcaption>`：`<figure>` 用于标记媒体内容，如图片、图表、视频等，而 `<figcaption>` 则为该媒体提供一个说明或标题。

- `<details>` 和 `<summary>`：`<details>` 用于创建一个可以显示或隐藏详细信息的可折叠小部件，`<summary>` 定义该小部件的可见标题。

- `<mark>`：突出显示文档中的文本，表示与上下文相关的重点或强调内容。

- `<time>`：定义日期或时间，有助于机器理解内容中的时间信息。

- `<dialog>`：用于创建对话框或模态窗口，原生支持开箱即用的对话框功能。

使用这些语义化标签，开发者可以构建更加结构化、易读、易理解的网页，同时也促进了网页内容的无障碍访问。

## 简要说明一下flex布局和grid布局

Flex布局（Flexible Box 或 Flexbox）和Grid布局（CSS Grid
Layout）是两种现代的、强大的CSS布局模型，它们为Web设计者提供了更灵活、高效的页面布局方式，替代了传统的基于浮动（floats）和定位（positioning）的布局方法。

### Flex布局

Flex布局是一种一维布局模型，主要用于处理元素在一维空间（行或列）上的布局问题，使其能够灵活地适应各种屏幕尺寸和设备。在Flex布局中，父元素称为**Flex容器**（flex container），而直接子元素则称为**Flex项目**
（flex items）。

#### 特点：

- **方向性**：可以轻松地控制项目在容器内的排列方向（水平或垂直）。
- **伸缩性**：自动调整项目大小以填充可用空间，或者分配剩余空间。
- **对齐**：提供了丰富的对齐选项，可以方便地控制项目在主轴和交叉轴上的对齐方式。
- **响应式**：非常适合创建响应式设计，能够简单地适应不同屏幕尺寸。

#### 常用属性：

- 在容器上：`display: flex;`、`flex-direction`、`justify-content`、`align-items`、`align-content`等。
- 在项目上：`flex-grow`、`flex-shrink`、`flex-basis`、`order`、`align-self`等。

### Grid布局

Grid布局是一种二维布局模型，专为解决复杂的二维网格布局问题而设计。它允许开发者创建一个由行和列组成的网格结构，然后将元素放置在网格中的特定单元格或跨越多个单元格。

#### 特点：

- **二维控制**：直接在二维平面上定位和大小调整元素。
- **复杂布局**：非常适合创建具有复杂结构的页面布局，如杂志版式设计。
- **自定义网格**：高度可定制的网格系统，可以定义网格的行数、列数、间距等。
- **区域命名**：可以为网格区域命名，然后通过名称将元素定位到特定区域。

#### 常用属性：

- 在容器上：`display: grid;`、`grid-template-columns`、`grid-template-rows`、`grid-gap`、`grid-template-areas`等。
- 在项目上：`grid-column`、`grid-row`、`grid-area`等，用于指定项目在网格中的位置。

### 总结

Flex布局擅长处理一维流式布局，特别是在需要元素沿一个方向（行或列）对齐和分布空间时非常有效。而Grid布局则更适用于二维布局，特别是需要精细控制元素在页面上的位置和大小的复杂布局场景。两者相辅相成，现代Web布局中常常结合使用，以实现更加灵活和高效的页面设计。

## js为什么有深拷贝和浅拷贝

JavaScript中有深拷贝和浅拷贝的概念，主要是因为对象（包括数组）在JavaScript中是以引用的方式存储的。这意味着当你创建一个对象或数组的副本时，你实际上复制的是这个对象或数组在内存中的引用（地址），而不是其内容本身。这就引出了深拷贝和浅拷贝的不同之处，以满足不同的使用场景。

### 浅拷贝（Shallow Copy）

- **定义**
  ：浅拷贝仅复制对象的第一层属性，如果对象的属性是基本数据类型（如字符串、数字、布尔值等），拷贝的就是这些值本身；但如果属性是引用类型（如对象、数组、函数等），拷贝的将是这些引用类型的地址，因此原对象和拷贝对象会共享这些深层次的引用类型属性。
- **用途**：适用于对象结构简单，且不需要完全隔离原始对象和拷贝对象的情况。
- **示例**：使用 Object.assign()、展开运算符（...）或 Array.prototype.slice()（对于数组）进行浅拷贝。

### 深拷贝（Deep Copy）

- **定义**：深拷贝会递归地复制对象的所有层级，包括嵌套的对象或数组，确保拷贝出的对象与原对象在内存中是完全独立的，没有任何关联。
- **用途**：当需要完全独立于原对象的新副本时，尤其是处理多层嵌套结构的对象或数组，深拷贝尤为重要。
- **示例**：可以手动实现深拷贝逻辑，使用递归遍历对象的所有属性并创建新对象，也可以使用第三方库如lodash的 _.cloneDeep() 方法。

### 为什么需要这两种拷贝？

- **数据隔离**：在某些情况下，你需要确保修改拷贝后的对象不会影响到原始对象，这时就需要深拷贝来创建完全独立的副本。
- **性能考虑**：浅拷贝相比于深拷贝来说，执行速度快，占用内存少，适合于只需要浅层次复制的场景。
- **资源管理**：深拷贝在处理大型或复杂对象时，可能会消耗更多资源，因此在不需要完全独立复制的情况下，使用浅拷贝更为高效。

总之，深拷贝和浅拷贝的存在是为了满足不同场景下对数据复制的需求，开发者需根据实际情况选择合适的拷贝方式。

## 常见的深拷贝、浅拷贝方法

### 浅拷贝方法

1. Object.assign()

```javascript
const shallowCopy = Object.assign({}, originalObject);
//注意：此方法对于嵌套的对象或数组仅进行浅拷贝。
```

2. 扩展运算符（Spread Operator）

```javascript
const shallowCopy = {...originalObject};
//同样，这也只适用于第一层属性的浅拷贝。
```

3. Array.prototype.slice() / Array.prototype.concat()

```javascript
const shallowCopy = originalArray.slice();
// 或
const shallowCopy = originalArray.concat([]);
```

### 深拷贝方法

1. JSON.parse() 和 JSON.stringify()

```javascript
const deepCopy = JSON.parse(JSON.stringify(original));
//注意：这种方法不适用于含有函数、RegExp、Date对象、undefined等特殊类型的对象
//因为JSON.stringify会忽略这些类型。
```

2. 递归实现,可以手动编写递归函数来实现深拷贝，检查并处理对象的每个属性：

```javascript
function deepCopy(obj) {
    if (typeof obj !== 'object' || obj === null) return obj;
    let copy = Array.isArray(obj) ? [] : {};
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            copy[key] = deepCopy(obj[key]);
        }
    }
    return copy;
}
```

3. 使用第三方库

Lodash 提供了 _.cloneDeep(value) 方法来实现深拷贝。

jQuery 也有 $.extend(true, {}, original) 方法可以实现深拷贝。